
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#include "schema.h"

namespace cfg {


bool test::TestExcelBean2::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readInt(y1)) return false;
    if(!_buf.readString(y2)) return false;
    if(!_buf.readFloat(y3)) return false;

    return true;
}

bool test::TestExcelBean2::deserializeTestExcelBean2(::luban::ByteBuf& _buf, ::luban::SharedPtr<test::TestExcelBean2>& _out)
{
    _out.reset(LUBAN_NEW(test::TestExcelBean2));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool test::TestGlobal::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readInt(unlockEquip)) return false;
    if(!_buf.readInt(unlockHero)) return false;

    return true;
}

bool test::TestGlobal::deserializeTestGlobal(::luban::ByteBuf& _buf, ::luban::SharedPtr<test::TestGlobal>& _out)
{
    _out.reset(LUBAN_NEW(test::TestGlobal));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool test::TestIndex::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readInt(id)) return false;
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); eles.reserve(n);for(int i = 0 ; i < n ; i++) { ::luban::SharedPtr<test::DemoType1> _e; if(!test::DemoType1::deserializeDemoType1(_buf, _e)) return false; eles.push_back(_e);}}

    return true;
}

bool test::TestIndex::deserializeTestIndex(::luban::ByteBuf& _buf, ::luban::SharedPtr<test::TestIndex>& _out)
{
    _out.reset(LUBAN_NEW(test::TestIndex));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool test::TestMap::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readInt(id)) return false;
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::luban::int32)_buf.size()); x1.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::luban::int32 _k; if(!_buf.readInt(_k)) return false; ::luban::int32 _v; if(!_buf.readInt(_v)) return false; x1[_k] = _v;}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::luban::int32)_buf.size()); x2.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::luban::int64 _k; if(!_buf.readLong(_k)) return false; ::luban::int32 _v; if(!_buf.readInt(_v)) return false; x2[_k] = _v;}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::luban::int32)_buf.size()); x3.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::luban::String _k; if(!_buf.readString(_k)) return false; ::luban::int32 _v; if(!_buf.readInt(_v)) return false; x3[_k] = _v;}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::luban::int32)_buf.size()); x4.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { test::DemoEnum _k; {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; _k = test::DemoEnum(__enum_temp__); } ::luban::int32 _v; if(!_buf.readInt(_v)) return false; x4[_k] = _v;}}

    return true;
}

bool test::TestMap::deserializeTestMap(::luban::ByteBuf& _buf, ::luban::SharedPtr<test::TestMap>& _out)
{
    _out.reset(LUBAN_NEW(test::TestMap));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool test::TestMapper::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readInt(id)) return false;
    {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; audioType = AudioType(__enum_temp__); }
    if(!vec2::deserializevec2(_buf, v2)) return false;

    return true;
}

bool test::TestMapper::deserializeTestMapper(::luban::ByteBuf& _buf, ::luban::SharedPtr<test::TestMapper>& _out)
{
    _out.reset(LUBAN_NEW(test::TestMapper));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool test::TestMultiColumn::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readInt(id)) return false;
    if(!test::Foo::deserializeFoo(_buf, a)) return false;
    if(!test::Foo::deserializeFoo(_buf, b)) return false;
    if(!test::Foo::deserializeFoo(_buf, c)) return false;

    return true;
}

bool test::TestMultiColumn::deserializeTestMultiColumn(::luban::ByteBuf& _buf, ::luban::SharedPtr<test::TestMultiColumn>& _out)
{
    _out.reset(LUBAN_NEW(test::TestMultiColumn));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool test::TestNull::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readInt(id)) return false;
    { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { x1.reset(new ::luban::int32()); if(!_buf.readInt(*x1)) return false; } else { x1.reset(); } }
    { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { x2.reset(new test::DemoEnum()); {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; *x2 = test::DemoEnum(__enum_temp__); } } else { x2.reset(); } }
    { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { x3.reset(); if(!test::DemoType1::deserializeDemoType1(_buf, x3)) return false; } else { x3.reset(); } }
    { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { x4.reset(); if(!test::DemoDynamic::deserializeDemoDynamic(_buf, x4)) return false; } else { x4.reset(); } }
    { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { s1.reset(new ::luban::String()); if(!_buf.readString(*s1)) return false; } else { s1.reset(); } }
    { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { s2.reset(new ::luban::String()); if(!_buf.readString(*s2)) return false; } else { s2.reset(); } }

    return true;
}

bool test::TestNull::deserializeTestNull(::luban::ByteBuf& _buf, ::luban::SharedPtr<test::TestNull>& _out)
{
    _out.reset(LUBAN_NEW(test::TestNull));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool test::TestRef::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readInt(id)) return false;
    if(!_buf.readInt(x1)) return false;
    if(!_buf.readInt(x12)) return false;
    if(!_buf.readInt(x2)) return false;
    if(!_buf.readInt(x3)) return false;
    if(!_buf.readInt(x4)) return false;
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); a1.reserve(n);for(int i = 0 ; i < n ; i++) { ::luban::int32 _e; if(!_buf.readInt(_e)) return false; a1.push_back(_e);}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); a2.reserve(n);for(int i = 0 ; i < n ; i++) { ::luban::int32 _e; if(!_buf.readInt(_e)) return false; a2.push_back(_e);}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); b1.reserve(n);for(int i = 0 ; i < n ; i++) { ::luban::int32 _e; if(!_buf.readInt(_e)) return false; b1.push_back(_e);}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); b2.reserve(n);for(int i = 0 ; i < n ; i++) { ::luban::int32 _e; if(!_buf.readInt(_e)) return false; b2.push_back(_e);}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); c1.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::luban::int32 _e; if(!_buf.readInt(_e)) return false; c1.insert(_e);}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); c2.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::luban::int32 _e; if(!_buf.readInt(_e)) return false; c2.insert(_e);}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::luban::int32)_buf.size()); d1.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::luban::int32 _k; if(!_buf.readInt(_k)) return false; ::luban::int32 _v; if(!_buf.readInt(_v)) return false; d1[_k] = _v;}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::luban::int32)_buf.size()); d2.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::luban::int32 _k; if(!_buf.readInt(_k)) return false; ::luban::int32 _v; if(!_buf.readInt(_v)) return false; d2[_k] = _v;}}
    if(!_buf.readInt(e1)) return false;
    if(!_buf.readLong(e2)) return false;
    if(!_buf.readString(e3)) return false;
    if(!_buf.readInt(f1)) return false;
    if(!_buf.readLong(f2)) return false;
    if(!_buf.readString(f3)) return false;
    if(!test::RefDynamicBase::deserializeRefDynamicBase(_buf, s1)) return false;

    return true;
}

bool test::TestRef::deserializeTestRef(::luban::ByteBuf& _buf, ::luban::SharedPtr<test::TestRef>& _out)
{
    _out.reset(LUBAN_NEW(test::TestRef));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool test::TestRow::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readInt(x)) return false;
    if (!_buf.readBool(y)) return false;
    if(!_buf.readString(z)) return false;
    if(!test::Test3::deserializeTest3(_buf, a)) return false;
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); b.reserve(n);for(int i = 0 ; i < n ; i++) { ::luban::int32 _e; if(!_buf.readInt(_e)) return false; b.push_back(_e);}}

    return true;
}

bool test::TestRow::deserializeTestRow(::luban::ByteBuf& _buf, ::luban::SharedPtr<test::TestRow>& _out)
{
    _out.reset(LUBAN_NEW(test::TestRow));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool test::TestScriptableObject::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readInt(id)) return false;
    if(!_buf.readString(desc)) return false;
    if(!_buf.readFloat(rate)) return false;
    if(!_buf.readInt(num)) return false;
    if(!vec2::deserializevec2(_buf, v2)) return false;
    if(!vec3::deserializevec3(_buf, v3)) return false;
    if(!vec4::deserializevec4(_buf, v4)) return false;

    return true;
}

bool test::TestScriptableObject::deserializeTestScriptableObject(::luban::ByteBuf& _buf, ::luban::SharedPtr<test::TestScriptableObject>& _out)
{
    _out.reset(LUBAN_NEW(test::TestScriptableObject));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool test::TestSet::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readInt(id)) return false;
    if(!_buf.readString(x0)) return false;
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); x1.reserve(n);for(int i = 0 ; i < n ; i++) { ::luban::int32 _e; if(!_buf.readInt(_e)) return false; x1.push_back(_e);}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); x2.reserve(n);for(int i = 0 ; i < n ; i++) { ::luban::int64 _e; if(!_buf.readLong(_e)) return false; x2.push_back(_e);}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); x3.reserve(n);for(int i = 0 ; i < n ; i++) { ::luban::String _e; if(!_buf.readString(_e)) return false; x3.push_back(_e);}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); x4.reserve(n);for(int i = 0 ; i < n ; i++) { test::DemoEnum _e; {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; _e = test::DemoEnum(__enum_temp__); } x4.push_back(_e);}}

    return true;
}

bool test::TestSet::deserializeTestSet(::luban::ByteBuf& _buf, ::luban::SharedPtr<test::TestSet>& _out)
{
    _out.reset(LUBAN_NEW(test::TestSet));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool test::TestSize::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readInt(id)) return false;
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); x1.reserve(n);for(int i = 0 ; i < n ; i++) { ::luban::int32 _e; if(!_buf.readInt(_e)) return false; x1.push_back(_e);}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); x2.reserve(n);for(int i = 0 ; i < n ; i++) { ::luban::int32 _e; if(!_buf.readInt(_e)) return false; x2.push_back(_e);}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); x3.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::luban::int32 _e; if(!_buf.readInt(_e)) return false; x3.insert(_e);}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::luban::int32)_buf.size()); x4.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::luban::int32 _k; if(!_buf.readInt(_k)) return false; ::luban::int32 _v; if(!_buf.readInt(_v)) return false; x4[_k] = _v;}}

    return true;
}

bool test::TestSize::deserializeTestSize(::luban::ByteBuf& _buf, ::luban::SharedPtr<test::TestSize>& _out)
{
    _out.reset(LUBAN_NEW(test::TestSize));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool test::TestString::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readString(id)) return false;
    if(!_buf.readString(s1)) return false;
    if(!_buf.readString(s2)) return false;
    if(!test::CompactString::deserializeCompactString(_buf, cs1)) return false;
    if(!test::CompactString::deserializeCompactString(_buf, cs2)) return false;

    return true;
}

bool test::TestString::deserializeTestString(::luban::ByteBuf& _buf, ::luban::SharedPtr<test::TestString>& _out)
{
    _out.reset(LUBAN_NEW(test::TestString));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool test::TestUeType::deserialize(::luban::ByteBuf& _buf)
{

    if (!_buf.readBool(x1)) return false;
    if(!_buf.readByte(x2)) return false;
    if(!_buf.readShort(x3)) return false;
    if(!_buf.readInt(x4)) return false;
    if(!_buf.readLong(x5)) return false;
    if(!_buf.readFloat(x6)) return false;
    if(!_buf.readString(x10)) return false;
    if(!test::DemoType1::deserializeDemoType1(_buf, x12)) return false;
    {int __enum_temp__; if(!_buf.readInt(__enum_temp__)) return false; x13 = test::ETestUeType(__enum_temp__); }
    if(!_buf.readLong(t1)) return false;
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); k1.reserve(n);for(int i = 0 ; i < n ; i++) { ::luban::int32 _e; if(!_buf.readInt(_e)) return false; k1.push_back(_e);}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); k2.reserve(n);for(int i = 0 ; i < n ; i++) { ::luban::int32 _e; if(!_buf.readInt(_e)) return false; k2.push_back(_e);}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); k5.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::luban::int32 _e; if(!_buf.readInt(_e)) return false; k5.insert(_e);}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::luban::int32)_buf.size()); k8.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::luban::int32 _k; if(!_buf.readInt(_k)) return false; ::luban::int32 _v; if(!_buf.readInt(_v)) return false; k8[_k] = _v;}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); k9.reserve(n);for(int i = 0 ; i < n ; i++) { ::luban::SharedPtr<test::DemoE2> _e; if(!test::DemoE2::deserializeDemoE2(_buf, _e)) return false; k9.push_back(_e);}}

    return true;
}

bool test::TestUeType::deserializeTestUeType(::luban::ByteBuf& _buf, ::luban::SharedPtr<test::TestUeType>& _out)
{
    _out.reset(LUBAN_NEW(test::TestUeType));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool vec2::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readFloat(x)) return false;
    if(!_buf.readFloat(y)) return false;

    return true;
}

bool vec2::deserializevec2(::luban::ByteBuf& _buf, ::luban::SharedPtr<vec2>& _out)
{
    _out.reset(LUBAN_NEW(vec2));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool vec3::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readFloat(x)) return false;
    if(!_buf.readFloat(y)) return false;
    if(!_buf.readFloat(z)) return false;

    return true;
}

bool vec3::deserializevec3(::luban::ByteBuf& _buf, ::luban::SharedPtr<vec3>& _out)
{
    _out.reset(LUBAN_NEW(vec3));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool vec4::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readFloat(x)) return false;
    if(!_buf.readFloat(y)) return false;
    if(!_buf.readFloat(z)) return false;
    if(!_buf.readFloat(w)) return false;

    return true;
}

bool vec4::deserializevec4(::luban::ByteBuf& _buf, ::luban::SharedPtr<vec4>& _out)
{
    _out.reset(LUBAN_NEW(vec4));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}

}

