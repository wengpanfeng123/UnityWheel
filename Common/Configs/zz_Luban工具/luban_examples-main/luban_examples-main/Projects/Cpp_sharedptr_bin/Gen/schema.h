
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#pragma once
#include <functional>
#include <algorithm>

#include "CfgBean.h"

namespace cfg {

namespace ai { 
    enum class EExecutor
    {
        CLIENT = 0,
        SERVER = 1,
    };

} 


namespace ai { 
    enum class EFinishMode
    {
        IMMEDIATE = 0,
        DELAYED = 1,
    };

} 


namespace ai { 
    enum class EFlowAbortMode
    {
        NONE = 0,
        LOWER_PRIORITY = 1,
        SELF = 2,
        BOTH = 3,
    };

} 


namespace ai { 
    enum class EKeyType
    {
        BOOL = 1,
        INT = 2,
        FLOAT = 3,
        STRING = 4,
        VECTOR = 5,
        ROTATOR = 6,
        NAME = 7,
        CLASS1 = 8,
        ENUM1 = 9,
        OBJECT = 10,
    };

} 


namespace ai { 
    enum class ENotifyObserverMode
    {
        ON_VALUE_CHANGE = 0,
        ON_RESULT_CHANGE = 1,
    };

} 


namespace ai { 
    enum class EOperator
    {
        IS_EQUAL_TO = 0,
        IS_NOT_EQUAL_TO = 1,
        IS_LESS_THAN = 2,
        IS_LESS_THAN_OR_EQUAL_TO = 3,
        IS_GREAT_THAN = 4,
        IS_GREAT_THAN_OR_EQUAL_TO = 5,
        CONTAINS = 6,
        NOT_CONTAINS = 7,
    };

} 


 
    enum class AudioType
    {
        UNKNOWN = 0,
        ACC = 1,
        AIFF = 2,
    };

 


namespace common { 
    enum class EBoolOperator
    {
        AND = 0,
        OR = 1,
    };

} 


namespace item { 
    enum class EClothersStarQualityType
    {
        /// <summary>
        /// 一星
        /// </summary>
        ONE = 1,
        /// <summary>
        /// 二星
        /// </summary>
        TWO = 2,
        /// <summary>
        /// 三星
        /// </summary>
        THREE = 3,
        /// <summary>
        /// 四星
        /// </summary>
        FOUR = 4,
        /// <summary>
        /// 五星
        /// </summary>
        FIVE = 5,
        /// <summary>
        /// 六星
        /// </summary>
        SIX = 6,
        /// <summary>
        /// 七星
        /// </summary>
        SEVEN = 7,
        /// <summary>
        /// 八星
        /// </summary>
        EIGHT = 8,
        /// <summary>
        /// 九星
        /// </summary>
        NINE = 9,
        /// <summary>
        /// 十星
        /// </summary>
        TEN = 10,
    };

} 


namespace item { 
    enum class EClothersTag
    {
        /// <summary>
        /// 防晒
        /// </summary>
        FANG_SHAI = 1,
        /// <summary>
        /// 舞者
        /// </summary>
        WU_ZHE = 2,
    };

} 


namespace item { 
    enum class EClothesHidePartType
    {
        /// <summary>
        /// 胸部
        /// </summary>
        CHEST = 0,
        /// <summary>
        /// 手
        /// </summary>
        HEAD = 1,
        /// <summary>
        /// 脊柱上
        /// </summary>
        SPINE_UPPER = 2,
        /// <summary>
        /// 脊柱下
        /// </summary>
        SPINE_LOWER = 3,
        /// <summary>
        /// 臀部
        /// </summary>
        HIP = 4,
        /// <summary>
        /// 腿上
        /// </summary>
        LEG_UPPER = 5,
        /// <summary>
        /// 腿中
        /// </summary>
        LEG_MIDDLE = 6,
        /// <summary>
        /// 腿下
        /// </summary>
        LEG_LOWER = 7,
    };

} 


namespace item { 
    enum class EClothesPropertyType
    {
        /// <summary>
        /// 简约
        /// </summary>
        JIAN_YUE = 1,
        /// <summary>
        /// 华丽
        /// </summary>
        HUA_LI = 2,
        /// <summary>
        /// 可爱
        /// </summary>
        KE_AI = 3,
        /// <summary>
        /// 成熟
        /// </summary>
        CHENG_SHU = 4,
        /// <summary>
        /// 活泼
        /// </summary>
        HUO_PO = 5,
        /// <summary>
        /// 优雅
        /// </summary>
        YOU_YA = 6,
        /// <summary>
        /// 清纯
        /// </summary>
        QING_CHUN = 7,
        /// <summary>
        /// 性感
        /// </summary>
        XING_GAN = 8,
        /// <summary>
        /// 清凉
        /// </summary>
        QING_LIANG = 9,
        /// <summary>
        /// 保暖
        /// </summary>
        BAO_NUAN = 10,
    };

} 


namespace item { 
    enum class ECurrencyType
    {
        /// <summary>
        /// 钻石
        /// </summary>
        DIAMOND = 1,
        /// <summary>
        /// 金币
        /// </summary>
        GOLD = 2,
        /// <summary>
        /// 银币
        /// </summary>
        SILVER = 3,
        /// <summary>
        /// 经验
        /// </summary>
        EXP = 4,
        /// <summary>
        /// 能量点
        /// </summary>
        POWER_POINT = 5,
    };

} 


namespace item { 
    /// <summary>
    /// 道具品质
    /// </summary>
    enum class EItemQuality
    {
        /// <summary>
        /// 白
        /// </summary>
        WHITE = 0,
        /// <summary>
        /// 绿
        /// </summary>
        GREEN = 1,
        /// <summary>
        /// 蓝
        /// </summary>
        BLUE = 2,
        /// <summary>
        /// 紫
        /// </summary>
        PURPLE = 3,
        /// <summary>
        /// 金
        /// </summary>
        GOLDEN = 4,
    };

} 


namespace item { 
    enum class EMajorType
    {
        /// <summary>
        /// 货币
        /// </summary>
        CURRENCY = 1,
        /// <summary>
        /// 服装
        /// </summary>
        CLOTH = 2,
        /// <summary>
        /// 任务
        /// </summary>
        QUEST = 3,
        /// <summary>
        /// 消耗品
        /// </summary>
        CONSUMABLES = 4,
        /// <summary>
        /// 宝箱
        /// </summary>
        TREASURE_BOX = 5,
        /// <summary>
        /// 成就和称谓
        /// </summary>
        ACHIEVEMENT_AND_TITLE = 6,
        /// <summary>
        /// 头像框
        /// </summary>
        HEAD_FRAME = 7,
        /// <summary>
        /// 语音
        /// </summary>
        VOICE = 8,
        /// <summary>
        /// 动作
        /// </summary>
        ACTION = 9,
        /// <summary>
        /// 扩容道具
        /// </summary>
        EXPANSION = 10,
        /// <summary>
        /// 制作材料
        /// </summary>
        MATERIAL = 11,
    };

} 


namespace item { 
    enum class EMinorType
    {
        /// <summary>
        /// 钻石
        /// </summary>
        DIAMOND = 101,
        /// <summary>
        /// 金币
        /// </summary>
        GOLD = 102,
        /// <summary>
        /// 银币
        /// </summary>
        SILVER = 103,
        /// <summary>
        /// 经验
        /// </summary>
        EXP = 104,
        /// <summary>
        /// 能量点
        /// </summary>
        POWER_POINT = 105,
        /// <summary>
        /// 发型
        /// </summary>
        HAIR_STYLE = 210,
        /// <summary>
        /// 外套
        /// </summary>
        COAT = 220,
        /// <summary>
        /// 上衣
        /// </summary>
        UPPER_JACKET = 230,
        /// <summary>
        /// 裤子
        /// </summary>
        TROUSERS = 241,
        /// <summary>
        /// 裙子
        /// </summary>
        SKIRT = 242,
        /// <summary>
        /// 袜子
        /// </summary>
        SOCKS = 250,
        /// <summary>
        /// 鞋子
        /// </summary>
        SHOES = 260,
        /// <summary>
        /// 发饰
        /// </summary>
        HAIR_ACCESSORY = 271,
        /// <summary>
        /// 帽子
        /// </summary>
        HAT = 272,
        /// <summary>
        /// 耳饰
        /// </summary>
        EARRING = 273,
        /// <summary>
        /// 颈饰
        /// </summary>
        NECKLACE = 274,
        /// <summary>
        /// 腕饰
        /// </summary>
        BRACELET = 275,
        /// <summary>
        /// 发箍
        /// </summary>
        HAIR_CLASP = 276,
        /// <summary>
        /// 手套
        /// </summary>
        GLOVE = 277,
        /// <summary>
        /// 手持物
        /// </summary>
        HANDHELD_OBJECT = 278,
        /// <summary>
        /// 特殊
        /// </summary>
        SPECIAL = 279,
        /// <summary>
        /// 底妆
        /// </summary>
        BASE_COSMETIC = 281,
        /// <summary>
        /// 眉妆
        /// </summary>
        EYEBROW_COSMETIC = 282,
        /// <summary>
        /// 睫毛
        /// </summary>
        EYELASH = 283,
        /// <summary>
        /// 美瞳
        /// </summary>
        COSMETIC_CONTACT_LENSES = 284,
        /// <summary>
        /// 唇妆
        /// </summary>
        LIP_COSMETIC = 285,
        /// <summary>
        /// 肤色
        /// </summary>
        SKIN_COLOR = 286,
        /// <summary>
        /// 连衣裙
        /// </summary>
        ONE_PIECE_DRESS = 290,
        /// <summary>
        /// 换装场景
        /// </summary>
        SWITCH_CLOTHES_SCENE = 291,
        /// <summary>
        /// 任务道具
        /// </summary>
        QUEST = 301,
        /// <summary>
        /// 投掷物
        /// </summary>
        CAST = 401,
        /// <summary>
        /// 刀剑
        /// </summary>
        SWORD = 421,
        /// <summary>
        /// 弓箭
        /// </summary>
        BOW_ARROW = 422,
        /// <summary>
        /// 法杖
        /// </summary>
        WANDS = 423,
        /// <summary>
        /// 特殊工具
        /// </summary>
        SPECIAL_TOOL = 424,
        /// <summary>
        /// 食物
        /// </summary>
        FOOD = 403,
        /// <summary>
        /// 宝箱
        /// </summary>
        TREASURE_BOX = 501,
        /// <summary>
        /// 钥匙
        /// </summary>
        KEY = 502,
        /// <summary>
        /// 多选一宝箱
        /// </summary>
        MULTI_CHOOSE_TREASURE_BOX = 503,
        /// <summary>
        /// 成就相关
        /// </summary>
        ACHIEVEMENT = 601,
        /// <summary>
        /// 称谓相关
        /// </summary>
        TITLE = 602,
        /// <summary>
        /// 头像框
        /// </summary>
        AVATAR_FRAME = 701,
        /// <summary>
        /// 语音
        /// </summary>
        VOICE = 801,
        /// <summary>
        /// 特殊待机动作
        /// </summary>
        IDLE_POSE = 901,
        /// <summary>
        /// 拍照动作
        /// </summary>
        PHOTO_POSE = 902,
        /// <summary>
        /// 背包
        /// </summary>
        BAG = 1001,
        /// <summary>
        /// 好友数量
        /// </summary>
        FRIEND_CAPACITY = 1002,
        /// <summary>
        /// 制作材料
        /// </summary>
        CONSTRUCTION_MATERIAL = 1101,
        /// <summary>
        /// 设计图纸
        /// </summary>
        DESIGN_DRAWING = 1102,
    };

} 


namespace item { 
    enum class EUseType
    {
        /// <summary>
        /// 手动
        /// </summary>
        MANUAL = 0,
        /// <summary>
        /// 自动
        /// </summary>
        AUTO = 1,
    };

} 


namespace test { 
    enum class AccessFlag
    {
        WRITE = 1,
        READ = 2,
        TRUNCATE = 4,
        NEW = 8,
        READ_WRITE = WRITE|READ,
    };

} 


namespace test { 
    enum class AudioType2
    {
        UNKNOWN = 0,
        ACC = 1,
        AIFF = 2,
    };

} 


namespace test { 
    enum class DemoEnum
    {
        NONE = 0,
        /// <summary>
        /// aa
        /// </summary>
        A = 1,
        /// <summary>
        /// bb
        /// </summary>
        B = 2,
        /// <summary>
        /// cc
        /// </summary>
        C = 4,
        /// <summary>
        /// dd
        /// </summary>
        D = 5,
        Any = 6,
    };

} 


namespace test { 
    enum class DemoFlag
    {
        A = 1,
        B = 2,
        C = 4,
        D = 8,
    };

} 


namespace test { 
    enum class ETestEmptyEnum
    {
    };

} 


namespace test { 
    enum class ETestEmptyEnum2
    {
        SMALL_THAN_256 = 255,
        X_256 = 256,
        X_257 = 257,
    };

} 


namespace test { 
    enum class ETestQuality
    {
        /// <summary>
        /// 最高品质
        /// </summary>
        A = 1,
        /// <summary>
        /// 黑色的
        /// </summary>
        B = 2,
        /// <summary>
        /// 蓝色的
        /// </summary>
        C = 3,
        /// <summary>
        /// 最差品质
        /// </summary>
        D = 4,
    };

} 


namespace test { 
    enum class ETestUeType
    {
        /// <summary>
        /// 白
        /// </summary>
        WHITE = 0,
        BLACK = 1,
    };

} 


namespace ai { struct BehaviorTree; }
namespace ai { struct Blackboard; }
namespace ai { struct BlackboardKey; }
namespace ai { struct KeyData; }
namespace ai { struct BlackboardKeyData; }
namespace ai { struct FloatKeyData; }
namespace ai { struct IntKeyData; }
namespace ai { struct StringKeyData; }
namespace ai { struct KeyQueryOperator; }
namespace ai { struct BinaryOperator; }
namespace ai { struct IsNotSet; }
namespace ai { struct IsSet2; }
namespace ai { struct Node; }
namespace ai { struct Decorator; }
namespace ai { struct DistanceLessThan; }
namespace ai { struct IsAtLocation; }
namespace ai { struct UeBlackboard; }
namespace ai { struct UeCooldown; }
namespace ai { struct UeForceSuccess; }
namespace ai { struct UeLoop; }
namespace ai { struct UeTimeLimit; }
namespace ai { struct FlowNode; }
namespace ai { struct ComposeNode; }
namespace ai { struct Selector; }
namespace ai { struct Sequence; }
namespace ai { struct SimpleParallel; }
namespace ai { struct Task; }
namespace ai { struct ChooseSkill; }
namespace ai { struct DebugPrint; }
namespace ai { struct MoveToLocation; }
namespace ai { struct MoveToRandomLocation; }
namespace ai { struct MoveToTarget; }
namespace ai { struct UeWait; }
namespace ai { struct UeWaitBlackboardTime; }
namespace ai { struct Service; }
namespace ai { struct ChooseTarget; }
namespace ai { struct ExecuteTimeStatistic; }
namespace ai { struct GetOwnerPlayer; }
namespace ai { struct KeepFaceTarget; }
namespace ai { struct UeSetDefaultFocus; }
namespace ai { struct UpdateDailyBehaviorProps; }
namespace common { struct DateTimeRange; }
namespace common { struct FloatRange; }
namespace common { struct GlobalConfig; }
namespace common { struct IntRange; }
namespace common { struct OneDayTimeRange; }
namespace common { struct TimeOfDay; }
 struct DefineFromExcel2; 
namespace item { struct Item; }
namespace l10n { struct L10NDemo; }
namespace l10n { struct PatchDemo; }
namespace tag { struct TestTag; }
namespace test { struct CompactString; }
namespace test { struct CompositeJsonTable1; }
namespace test { struct CompositeJsonTable2; }
namespace test { struct CompositeJsonTable3; }
namespace test { struct DateTimeRange; }
namespace test { struct DemoDynamic; }
namespace test { struct DemoD2; }
namespace test { struct DemoD3; }
namespace test { struct DemoE1; }
namespace test {namespace login { struct RoleInfo; }}
namespace test { struct DemoD5; }
namespace test { struct DemoE2; }
namespace test { struct DemoExplicitType; }
namespace test { struct DemoGroup; }
namespace test { struct DemoPrimitiveTypesTable; }
namespace test { struct DemoSingletonType; }
namespace test { struct DemoType1; }
namespace test { struct DemoType2; }
namespace test { struct DetectEncoding; }
namespace test { struct ExcelFromJson; }
namespace test { struct ExcelFromJsonMultiRow; }
namespace test { struct Foo; }
namespace test { struct H1; }
namespace test { struct H2; }
namespace test { struct InnerGroup; }
namespace test { struct ItemBase; }
namespace test { struct Decorator; }
namespace test { struct Equipment; }
namespace test { struct Item; }
namespace test { struct MultiIndexList; }
namespace test { struct MultiRowRecord; }
namespace test { struct MultiRowTitle; }
namespace test { struct MultiRowType1; }
namespace test { struct MultiRowType2; }
namespace test { struct MultiRowType3; }
namespace test { struct MultiUnionIndexList; }
namespace test { struct NotIndexList; }
namespace test { struct Path; }
namespace test { struct RefDynamicBase; }
namespace test { struct RefBean; }
namespace test { struct SepBean1; }
namespace test { struct SepVector; }
namespace test { struct Shape; }
namespace test { struct Circle; }
namespace test2 { struct Rectangle; }
namespace test { struct Test3; }
namespace test { struct TestBeRef; }
namespace test { struct TestExcelBean1; }
namespace test { struct TestExcelBean2; }
namespace test { struct TestGlobal; }
namespace test { struct TestIndex; }
namespace test { struct TestMap; }
namespace test { struct TestMapper; }
namespace test { struct TestMultiColumn; }
namespace test { struct TestNull; }
namespace test { struct TestRef; }
namespace test { struct TestRow; }
namespace test { struct TestScriptableObject; }
namespace test { struct TestSet; }
namespace test { struct TestSize; }
namespace test { struct TestString; }
namespace test { struct TestUeType; }
 struct vec2; 
 struct vec3; 
 struct vec4; 

namespace ai {

struct BehaviorTree : public luban::CfgBean 
{
    static bool deserializeBehaviorTree(::luban::ByteBuf& _buf, ::luban::SharedPtr<BehaviorTree>& _out);

    virtual ~BehaviorTree() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    ::luban::String name;
    ::luban::String desc;
    ::luban::String blackboardId;
    ::luban::SharedPtr<ai::ComposeNode> root;

    static constexpr int __ID__ = 159552822;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct Blackboard : public luban::CfgBean 
{
    static bool deserializeBlackboard(::luban::ByteBuf& _buf, ::luban::SharedPtr<Blackboard>& _out);

    virtual ~Blackboard() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::String name;
    ::luban::String desc;
    ::luban::String parentName;
    ::luban::Vector<::luban::SharedPtr<ai::BlackboardKey>> keys;

    static constexpr int __ID__ = 1576193005;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct BlackboardKey : public luban::CfgBean 
{
    static bool deserializeBlackboardKey(::luban::ByteBuf& _buf, ::luban::SharedPtr<BlackboardKey>& _out);

    virtual ~BlackboardKey() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::String name;
    ::luban::String desc;
    bool isStatic;
    ai::EKeyType keyType;
    ::luban::String typeClassName;

    static constexpr int __ID__ = -511559886;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct KeyData : public luban::CfgBean 
{
    static bool deserializeKeyData(::luban::ByteBuf& _buf, ::luban::SharedPtr<KeyData>& _out);

    virtual ~KeyData() {}

    bool deserialize(::luban::ByteBuf& _buf);


};

}

namespace ai {

struct BlackboardKeyData : public ai::KeyData 
{
    static bool deserializeBlackboardKeyData(::luban::ByteBuf& _buf, ::luban::SharedPtr<BlackboardKeyData>& _out);

    virtual ~BlackboardKeyData() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::String value;

    static constexpr int __ID__ = 1517269500;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct FloatKeyData : public ai::KeyData 
{
    static bool deserializeFloatKeyData(::luban::ByteBuf& _buf, ::luban::SharedPtr<FloatKeyData>& _out);

    virtual ~FloatKeyData() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::float32 value;

    static constexpr int __ID__ = -719747885;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct IntKeyData : public ai::KeyData 
{
    static bool deserializeIntKeyData(::luban::ByteBuf& _buf, ::luban::SharedPtr<IntKeyData>& _out);

    virtual ~IntKeyData() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 value;

    static constexpr int __ID__ = -342751904;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct StringKeyData : public ai::KeyData 
{
    static bool deserializeStringKeyData(::luban::ByteBuf& _buf, ::luban::SharedPtr<StringKeyData>& _out);

    virtual ~StringKeyData() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::String value;

    static constexpr int __ID__ = -307888654;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct KeyQueryOperator : public luban::CfgBean 
{
    static bool deserializeKeyQueryOperator(::luban::ByteBuf& _buf, ::luban::SharedPtr<KeyQueryOperator>& _out);

    virtual ~KeyQueryOperator() {}

    bool deserialize(::luban::ByteBuf& _buf);


};

}

namespace ai {

struct BinaryOperator : public ai::KeyQueryOperator 
{
    static bool deserializeBinaryOperator(::luban::ByteBuf& _buf, ::luban::SharedPtr<BinaryOperator>& _out);

    virtual ~BinaryOperator() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ai::EOperator oper;
    ::luban::SharedPtr<ai::KeyData> data;

    static constexpr int __ID__ = -979891605;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct IsNotSet : public ai::KeyQueryOperator 
{
    static bool deserializeIsNotSet(::luban::ByteBuf& _buf, ::luban::SharedPtr<IsNotSet>& _out);

    virtual ~IsNotSet() {}

    bool deserialize(::luban::ByteBuf& _buf);


    static constexpr int __ID__ = 790736255;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct IsSet2 : public ai::KeyQueryOperator 
{
    static bool deserializeIsSet2(::luban::ByteBuf& _buf, ::luban::SharedPtr<IsSet2>& _out);

    virtual ~IsSet2() {}

    bool deserialize(::luban::ByteBuf& _buf);


    static constexpr int __ID__ = -843729664;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct Node : public luban::CfgBean 
{
    static bool deserializeNode(::luban::ByteBuf& _buf, ::luban::SharedPtr<Node>& _out);

    virtual ~Node() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    ::luban::String nodeName;

};

}

namespace ai {

struct Decorator : public ai::Node 
{
    static bool deserializeDecorator(::luban::ByteBuf& _buf, ::luban::SharedPtr<Decorator>& _out);

    virtual ~Decorator() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ai::EFlowAbortMode flowAbortMode;

};

}

namespace ai {

struct DistanceLessThan : public ai::Decorator 
{
    static bool deserializeDistanceLessThan(::luban::ByteBuf& _buf, ::luban::SharedPtr<DistanceLessThan>& _out);

    virtual ~DistanceLessThan() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::String actor1Key;
    ::luban::String actor2Key;
    ::luban::float32 distance;
    bool reverseResult;

    static constexpr int __ID__ = -1207170283;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct IsAtLocation : public ai::Decorator 
{
    static bool deserializeIsAtLocation(::luban::ByteBuf& _buf, ::luban::SharedPtr<IsAtLocation>& _out);

    virtual ~IsAtLocation() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::float32 acceptableRadius;
    ::luban::String keyboardKey;
    bool inverseCondition;

    static constexpr int __ID__ = 1255972344;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct UeBlackboard : public ai::Decorator 
{
    static bool deserializeUeBlackboard(::luban::ByteBuf& _buf, ::luban::SharedPtr<UeBlackboard>& _out);

    virtual ~UeBlackboard() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ai::ENotifyObserverMode notifyObserver;
    ::luban::String blackboardKey;
    ::luban::SharedPtr<ai::KeyQueryOperator> keyQuery;

    static constexpr int __ID__ = -315297507;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct UeCooldown : public ai::Decorator 
{
    static bool deserializeUeCooldown(::luban::ByteBuf& _buf, ::luban::SharedPtr<UeCooldown>& _out);

    virtual ~UeCooldown() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::float32 cooldownTime;

    static constexpr int __ID__ = -951439423;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct UeForceSuccess : public ai::Decorator 
{
    static bool deserializeUeForceSuccess(::luban::ByteBuf& _buf, ::luban::SharedPtr<UeForceSuccess>& _out);

    virtual ~UeForceSuccess() {}

    bool deserialize(::luban::ByteBuf& _buf);


    static constexpr int __ID__ = 195054574;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct UeLoop : public ai::Decorator 
{
    static bool deserializeUeLoop(::luban::ByteBuf& _buf, ::luban::SharedPtr<UeLoop>& _out);

    virtual ~UeLoop() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 numLoops;
    bool infiniteLoop;
    ::luban::float32 infiniteLoopTimeoutTime;

    static constexpr int __ID__ = -513308166;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct UeTimeLimit : public ai::Decorator 
{
    static bool deserializeUeTimeLimit(::luban::ByteBuf& _buf, ::luban::SharedPtr<UeTimeLimit>& _out);

    virtual ~UeTimeLimit() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::float32 limitTime;

    static constexpr int __ID__ = 338469720;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct FlowNode : public ai::Node 
{
    static bool deserializeFlowNode(::luban::ByteBuf& _buf, ::luban::SharedPtr<FlowNode>& _out);

    virtual ~FlowNode() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::Vector<::luban::SharedPtr<ai::Decorator>> decorators;
    ::luban::Vector<::luban::SharedPtr<ai::Service>> services;

};

}

namespace ai {

struct ComposeNode : public ai::FlowNode 
{
    static bool deserializeComposeNode(::luban::ByteBuf& _buf, ::luban::SharedPtr<ComposeNode>& _out);

    virtual ~ComposeNode() {}

    bool deserialize(::luban::ByteBuf& _buf);


};

}

namespace ai {

struct Selector : public ai::ComposeNode 
{
    static bool deserializeSelector(::luban::ByteBuf& _buf, ::luban::SharedPtr<Selector>& _out);

    virtual ~Selector() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::Vector<::luban::SharedPtr<ai::FlowNode>> children;

    static constexpr int __ID__ = -1946981627;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct Sequence : public ai::ComposeNode 
{
    static bool deserializeSequence(::luban::ByteBuf& _buf, ::luban::SharedPtr<Sequence>& _out);

    virtual ~Sequence() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::Vector<::luban::SharedPtr<ai::FlowNode>> children;

    static constexpr int __ID__ = -1789006105;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct SimpleParallel : public ai::ComposeNode 
{
    static bool deserializeSimpleParallel(::luban::ByteBuf& _buf, ::luban::SharedPtr<SimpleParallel>& _out);

    virtual ~SimpleParallel() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ai::EFinishMode finishMode;
    ::luban::SharedPtr<ai::Task> mainTask;
    ::luban::SharedPtr<ai::FlowNode> backgroundNode;

    static constexpr int __ID__ = -1952582529;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct Task : public ai::FlowNode 
{
    static bool deserializeTask(::luban::ByteBuf& _buf, ::luban::SharedPtr<Task>& _out);

    virtual ~Task() {}

    bool deserialize(::luban::ByteBuf& _buf);

    bool ignoreRestartSelf;

};

}

namespace ai {

struct ChooseSkill : public ai::Task 
{
    static bool deserializeChooseSkill(::luban::ByteBuf& _buf, ::luban::SharedPtr<ChooseSkill>& _out);

    virtual ~ChooseSkill() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::String targetActorKey;
    ::luban::String resultSkillIdKey;

    static constexpr int __ID__ = -918812268;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct DebugPrint : public ai::Task 
{
    static bool deserializeDebugPrint(::luban::ByteBuf& _buf, ::luban::SharedPtr<DebugPrint>& _out);

    virtual ~DebugPrint() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::String text;

    static constexpr int __ID__ = 1357409728;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct MoveToLocation : public ai::Task 
{
    static bool deserializeMoveToLocation(::luban::ByteBuf& _buf, ::luban::SharedPtr<MoveToLocation>& _out);

    virtual ~MoveToLocation() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::float32 acceptableRadius;

    static constexpr int __ID__ = -969953113;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct MoveToRandomLocation : public ai::Task 
{
    static bool deserializeMoveToRandomLocation(::luban::ByteBuf& _buf, ::luban::SharedPtr<MoveToRandomLocation>& _out);

    virtual ~MoveToRandomLocation() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::String originPositionKey;
    ::luban::float32 radius;

    static constexpr int __ID__ = -2140042998;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct MoveToTarget : public ai::Task 
{
    static bool deserializeMoveToTarget(::luban::ByteBuf& _buf, ::luban::SharedPtr<MoveToTarget>& _out);

    virtual ~MoveToTarget() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::String targetActorKey;
    ::luban::float32 acceptableRadius;

    static constexpr int __ID__ = 514987779;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct UeWait : public ai::Task 
{
    static bool deserializeUeWait(::luban::ByteBuf& _buf, ::luban::SharedPtr<UeWait>& _out);

    virtual ~UeWait() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::float32 waitTime;
    ::luban::float32 randomDeviation;

    static constexpr int __ID__ = -512994101;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct UeWaitBlackboardTime : public ai::Task 
{
    static bool deserializeUeWaitBlackboardTime(::luban::ByteBuf& _buf, ::luban::SharedPtr<UeWaitBlackboardTime>& _out);

    virtual ~UeWaitBlackboardTime() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::String blackboardKey;

    static constexpr int __ID__ = 1215378271;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct Service : public ai::Node 
{
    static bool deserializeService(::luban::ByteBuf& _buf, ::luban::SharedPtr<Service>& _out);

    virtual ~Service() {}

    bool deserialize(::luban::ByteBuf& _buf);


};

}

namespace ai {

struct ChooseTarget : public ai::Service 
{
    static bool deserializeChooseTarget(::luban::ByteBuf& _buf, ::luban::SharedPtr<ChooseTarget>& _out);

    virtual ~ChooseTarget() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::String resultTargetKey;

    static constexpr int __ID__ = 1601247918;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct ExecuteTimeStatistic : public ai::Service 
{
    static bool deserializeExecuteTimeStatistic(::luban::ByteBuf& _buf, ::luban::SharedPtr<ExecuteTimeStatistic>& _out);

    virtual ~ExecuteTimeStatistic() {}

    bool deserialize(::luban::ByteBuf& _buf);


    static constexpr int __ID__ = 990693812;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct GetOwnerPlayer : public ai::Service 
{
    static bool deserializeGetOwnerPlayer(::luban::ByteBuf& _buf, ::luban::SharedPtr<GetOwnerPlayer>& _out);

    virtual ~GetOwnerPlayer() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::String playerActorKey;

    static constexpr int __ID__ = -999247644;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct KeepFaceTarget : public ai::Service 
{
    static bool deserializeKeepFaceTarget(::luban::ByteBuf& _buf, ::luban::SharedPtr<KeepFaceTarget>& _out);

    virtual ~KeepFaceTarget() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::String targetActorKey;

    static constexpr int __ID__ = 1195270745;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct UeSetDefaultFocus : public ai::Service 
{
    static bool deserializeUeSetDefaultFocus(::luban::ByteBuf& _buf, ::luban::SharedPtr<UeSetDefaultFocus>& _out);

    virtual ~UeSetDefaultFocus() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::String keyboardKey;

    static constexpr int __ID__ = 1812449155;

    int getTypeId() const override { return __ID__; }
};

}

namespace ai {

struct UpdateDailyBehaviorProps : public ai::Service 
{
    static bool deserializeUpdateDailyBehaviorProps(::luban::ByteBuf& _buf, ::luban::SharedPtr<UpdateDailyBehaviorProps>& _out);

    virtual ~UpdateDailyBehaviorProps() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::String satietyKey;
    ::luban::String energyKey;
    ::luban::String moodKey;
    ::luban::String satietyLowerThresholdKey;
    ::luban::String satietyUpperThresholdKey;
    ::luban::String energyLowerThresholdKey;
    ::luban::String energyUpperThresholdKey;
    ::luban::String moodLowerThresholdKey;
    ::luban::String moodUpperThresholdKey;

    static constexpr int __ID__ = -61887372;

    int getTypeId() const override { return __ID__; }
};

}

namespace common {

struct DateTimeRange : public luban::CfgBean 
{
    static bool deserializeDateTimeRange(::luban::ByteBuf& _buf, ::luban::SharedPtr<DateTimeRange>& _out);

    virtual ~DateTimeRange() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::SharedPtr<::luban::datetime> startTime;
    ::luban::SharedPtr<::luban::datetime> endTime;

    static constexpr int __ID__ = 1642200959;

    int getTypeId() const override { return __ID__; }
};

}

namespace common {

struct FloatRange : public luban::CfgBean 
{
    static bool deserializeFloatRange(::luban::ByteBuf& _buf, ::luban::SharedPtr<FloatRange>& _out);

    virtual ~FloatRange() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::float32 min;
    ::luban::float32 max;

    static constexpr int __ID__ = 561922116;

    int getTypeId() const override { return __ID__; }
};

}

namespace common {

struct GlobalConfig : public luban::CfgBean 
{
    static bool deserializeGlobalConfig(::luban::ByteBuf& _buf, ::luban::SharedPtr<GlobalConfig>& _out);

    virtual ~GlobalConfig() {}

    bool deserialize(::luban::ByteBuf& _buf);

    /**
     * 背包容量
     */
    ::luban::int32 x1;
    ::luban::int32 x2;
    ::luban::int32 x3;
    ::luban::int32 x4;
    ::luban::int32 x5;
    ::luban::int32 x6;
    ::luban::Vector<::luban::int32> x7;

    static constexpr int __ID__ = -848234488;

    int getTypeId() const override { return __ID__; }
};

}

namespace common {

struct IntRange : public luban::CfgBean 
{
    static bool deserializeIntRange(::luban::ByteBuf& _buf, ::luban::SharedPtr<IntRange>& _out);

    virtual ~IntRange() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 min;
    ::luban::int32 max;

    static constexpr int __ID__ = -751013039;

    int getTypeId() const override { return __ID__; }
};

}

namespace common {

struct OneDayTimeRange : public luban::CfgBean 
{
    static bool deserializeOneDayTimeRange(::luban::ByteBuf& _buf, ::luban::SharedPtr<OneDayTimeRange>& _out);

    virtual ~OneDayTimeRange() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::SharedPtr<common::TimeOfDay> startTime;
    ::luban::SharedPtr<common::TimeOfDay> endTime;

    static constexpr int __ID__ = 1628814743;

    int getTypeId() const override { return __ID__; }
};

}

namespace common {

struct TimeOfDay : public luban::CfgBean 
{
    static bool deserializeTimeOfDay(::luban::ByteBuf& _buf, ::luban::SharedPtr<TimeOfDay>& _out);

    virtual ~TimeOfDay() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 hour;
    ::luban::int32 minute;
    ::luban::int32 second;

    static constexpr int __ID__ = -1728347371;

    int getTypeId() const override { return __ID__; }
};

}



struct DefineFromExcel2 : public luban::CfgBean 
{
    static bool deserializeDefineFromExcel2(::luban::ByteBuf& _buf, ::luban::SharedPtr<DefineFromExcel2>& _out);

    virtual ~DefineFromExcel2() {}

    bool deserialize(::luban::ByteBuf& _buf);

    /**
     * 这是id
     */
    ::luban::int32 id;
    /**
     * 字段x1
     */
    bool x1;
    ::luban::int64 x5;
    ::luban::float32 x6;
    ::luban::int32 x8;
    ::luban::String x10;
    test::DemoEnum x13;
    test::DemoFlag x132;
    ::luban::SharedPtr<test::DemoDynamic> x14;
    ::luban::SharedPtr<test::Shape> x15;
    ::luban::SharedPtr<vec2> v2;
    ::luban::datetime t1;
    ::luban::Array<::luban::int32> k1;
    ::luban::Array<::luban::int32> k2;
    ::luban::HashMap<::luban::int32, ::luban::int32> k8;
    ::luban::Vector<::luban::SharedPtr<test::DemoE2>> k9;
    ::luban::Vector<::luban::SharedPtr<vec3>> k10;
    ::luban::Vector<::luban::SharedPtr<vec4>> k11;
    ::luban::SharedPtr<vec3> v11;

    static constexpr int __ID__ = 482045152;

    int getTypeId() const override { return __ID__; }
};



namespace item {

/**
 * 道具
 */
struct Item : public luban::CfgBean 
{
    static bool deserializeItem(::luban::ByteBuf& _buf, ::luban::SharedPtr<Item>& _out);

    virtual ~Item() {}

    bool deserialize(::luban::ByteBuf& _buf);

    /**
     * 道具id
     */
    ::luban::int32 id;
    ::luban::String name;
    item::EMajorType majorType;
    item::EMinorType minorType;
    ::luban::int32 maxPileNum;
    item::EItemQuality quality;
    ::luban::String icon;
    ::luban::String iconBackgroud;
    ::luban::String iconMask;
    ::luban::String desc;
    ::luban::int32 showOrder;

    static constexpr int __ID__ = 2107285806;

    int getTypeId() const override { return __ID__; }
};

}

namespace l10n {

struct L10NDemo : public luban::CfgBean 
{
    static bool deserializeL10NDemo(::luban::ByteBuf& _buf, ::luban::SharedPtr<L10NDemo>& _out);

    virtual ~L10NDemo() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    ::luban::String text;

    static constexpr int __ID__ = -331195887;

    int getTypeId() const override { return __ID__; }
};

}

namespace l10n {

struct PatchDemo : public luban::CfgBean 
{
    static bool deserializePatchDemo(::luban::ByteBuf& _buf, ::luban::SharedPtr<PatchDemo>& _out);

    virtual ~PatchDemo() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    ::luban::int32 value;

    static constexpr int __ID__ = -1707294656;

    int getTypeId() const override { return __ID__; }
};

}

namespace tag {

struct TestTag : public luban::CfgBean 
{
    static bool deserializeTestTag(::luban::ByteBuf& _buf, ::luban::SharedPtr<TestTag>& _out);

    virtual ~TestTag() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    ::luban::String value;

    static constexpr int __ID__ = 1742933812;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct CompactString : public luban::CfgBean 
{
    static bool deserializeCompactString(::luban::ByteBuf& _buf, ::luban::SharedPtr<CompactString>& _out);

    virtual ~CompactString() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    ::luban::String s2;
    ::luban::String s3;

    static constexpr int __ID__ = 1968089240;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct CompositeJsonTable1 : public luban::CfgBean 
{
    static bool deserializeCompositeJsonTable1(::luban::ByteBuf& _buf, ::luban::SharedPtr<CompositeJsonTable1>& _out);

    virtual ~CompositeJsonTable1() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    ::luban::String x;

    static constexpr int __ID__ = 1566207894;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct CompositeJsonTable2 : public luban::CfgBean 
{
    static bool deserializeCompositeJsonTable2(::luban::ByteBuf& _buf, ::luban::SharedPtr<CompositeJsonTable2>& _out);

    virtual ~CompositeJsonTable2() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    ::luban::int32 y;

    static constexpr int __ID__ = 1566207895;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct CompositeJsonTable3 : public luban::CfgBean 
{
    static bool deserializeCompositeJsonTable3(::luban::ByteBuf& _buf, ::luban::SharedPtr<CompositeJsonTable3>& _out);

    virtual ~CompositeJsonTable3() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 a;
    ::luban::int32 b;

    static constexpr int __ID__ = 1566207896;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct DateTimeRange : public luban::CfgBean 
{
    static bool deserializeDateTimeRange(::luban::ByteBuf& _buf, ::luban::SharedPtr<DateTimeRange>& _out);

    virtual ~DateTimeRange() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::datetime startTime;
    ::luban::datetime endTime;

    static constexpr int __ID__ = 495315430;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct DemoDynamic : public luban::CfgBean 
{
    static bool deserializeDemoDynamic(::luban::ByteBuf& _buf, ::luban::SharedPtr<DemoDynamic>& _out);

    virtual ~DemoDynamic() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 x1;

};

}

namespace test {

struct DemoD2 : public test::DemoDynamic 
{
    static bool deserializeDemoD2(::luban::ByteBuf& _buf, ::luban::SharedPtr<DemoD2>& _out);

    virtual ~DemoD2() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 x2;

    static constexpr int __ID__ = -2138341747;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct DemoD3 : public test::DemoDynamic 
{
    static bool deserializeDemoD3(::luban::ByteBuf& _buf, ::luban::SharedPtr<DemoD3>& _out);

    virtual ~DemoD3() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 x3;

};

}

namespace test {

struct DemoE1 : public test::DemoD3 
{
    static bool deserializeDemoE1(::luban::ByteBuf& _buf, ::luban::SharedPtr<DemoE1>& _out);

    virtual ~DemoE1() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 x4;

    static constexpr int __ID__ = -2138341717;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {namespace login {

struct RoleInfo : public test::DemoD3 
{
    static bool deserializeRoleInfo(::luban::ByteBuf& _buf, ::luban::SharedPtr<RoleInfo>& _out);

    virtual ~RoleInfo() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int64 roleId;

    static constexpr int __ID__ = -989153243;

    int getTypeId() const override { return __ID__; }
};

}}

namespace test {

struct DemoD5 : public test::DemoDynamic 
{
    static bool deserializeDemoD5(::luban::ByteBuf& _buf, ::luban::SharedPtr<DemoD5>& _out);

    virtual ~DemoD5() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::SharedPtr<test::DateTimeRange> time;

    static constexpr int __ID__ = -2138341744;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct DemoE2 : public luban::CfgBean 
{
    static bool deserializeDemoE2(::luban::ByteBuf& _buf, ::luban::SharedPtr<DemoE2>& _out);

    virtual ~DemoE2() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::SharedPtr<::luban::int32> y1;
    bool y2;

    static constexpr int __ID__ = -2138341716;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct DemoExplicitType : public luban::CfgBean 
{
    static bool deserializeDemoExplicitType(::luban::ByteBuf& _buf, ::luban::SharedPtr<DemoExplicitType>& _out);

    virtual ~DemoExplicitType() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::byte x1;
    ::luban::int16 x2;
    ::luban::int32 x3;
    ::luban::int64 x4;
    ::luban::float32 x5;
    ::luban::float64 x6;
    ::luban::int64 x7;

    static constexpr int __ID__ = 370351885;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct DemoGroup : public luban::CfgBean 
{
    static bool deserializeDemoGroup(::luban::ByteBuf& _buf, ::luban::SharedPtr<DemoGroup>& _out);

    virtual ~DemoGroup() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    ::luban::int32 x1;
    ::luban::int32 x2;
    ::luban::int32 x3;
    ::luban::int32 x4;
    ::luban::SharedPtr<test::InnerGroup> x5;

    static constexpr int __ID__ = -379263008;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct DemoPrimitiveTypesTable : public luban::CfgBean 
{
    static bool deserializeDemoPrimitiveTypesTable(::luban::ByteBuf& _buf, ::luban::SharedPtr<DemoPrimitiveTypesTable>& _out);

    virtual ~DemoPrimitiveTypesTable() {}

    bool deserialize(::luban::ByteBuf& _buf);

    bool x1;
    ::luban::byte x2;
    ::luban::int16 x3;
    ::luban::int32 x4;
    ::luban::int64 x5;
    ::luban::float32 x6;
    ::luban::float64 x7;
    ::luban::String s1;
    ::luban::String s2;
    ::luban::SharedPtr<vec2> v2;
    ::luban::SharedPtr<vec3> v3;
    ::luban::SharedPtr<vec4> v4;
    ::luban::datetime t1;

    static constexpr int __ID__ = -370934083;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct DemoSingletonType : public luban::CfgBean 
{
    static bool deserializeDemoSingletonType(::luban::ByteBuf& _buf, ::luban::SharedPtr<DemoSingletonType>& _out);

    virtual ~DemoSingletonType() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    ::luban::String name;
    ::luban::SharedPtr<test::DemoDynamic> date;

    static constexpr int __ID__ = 539196998;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct DemoType1 : public luban::CfgBean 
{
    static bool deserializeDemoType1(::luban::ByteBuf& _buf, ::luban::SharedPtr<DemoType1>& _out);

    virtual ~DemoType1() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 x1;

    static constexpr int __ID__ = -367048296;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct DemoType2 : public luban::CfgBean 
{
    static bool deserializeDemoType2(::luban::ByteBuf& _buf, ::luban::SharedPtr<DemoType2>& _out);

    virtual ~DemoType2() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 x4;
    bool x1;
    ::luban::byte x2;
    ::luban::int16 x3;
    ::luban::int64 x5;
    ::luban::float32 x6;
    ::luban::float64 x7;
    ::luban::int16 x80;
    ::luban::int32 x8;
    ::luban::int64 x9;
    ::luban::String x10;
    ::luban::SharedPtr<test::DemoType1> x12;
    test::DemoEnum x13;
    ::luban::SharedPtr<test::DemoDynamic> x14;
    ::luban::String s1;
    ::luban::datetime t1;
    ::luban::Array<::luban::int32> k1;
    ::luban::Vector<::luban::int32> k2;
    ::luban::HashSet<::luban::int32> k5;
    ::luban::HashMap<::luban::int32, ::luban::int32> k8;
    ::luban::Vector<::luban::SharedPtr<test::DemoE2>> k9;
    ::luban::Array<::luban::SharedPtr<test::DemoDynamic>> k15;

    static constexpr int __ID__ = -367048295;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct DetectEncoding : public luban::CfgBean 
{
    static bool deserializeDetectEncoding(::luban::ByteBuf& _buf, ::luban::SharedPtr<DetectEncoding>& _out);

    virtual ~DetectEncoding() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    ::luban::String name;

    static constexpr int __ID__ = -1154609646;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct ExcelFromJson : public luban::CfgBean 
{
    static bool deserializeExcelFromJson(::luban::ByteBuf& _buf, ::luban::SharedPtr<ExcelFromJson>& _out);

    virtual ~ExcelFromJson() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 x4;
    bool x1;
    ::luban::int64 x5;
    ::luban::float32 x6;
    ::luban::String s1;
    ::luban::String s2;
    ::luban::datetime t1;
    ::luban::SharedPtr<test::DemoType1> x12;
    test::DemoEnum x13;
    ::luban::SharedPtr<test::DemoDynamic> x14;
    ::luban::Array<::luban::int32> k1;
    ::luban::HashMap<::luban::int32, ::luban::int32> k8;
    ::luban::Vector<::luban::SharedPtr<test::DemoE2>> k9;
    ::luban::Array<::luban::SharedPtr<test::DemoDynamic>> k15;

    static constexpr int __ID__ = -1485706483;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct ExcelFromJsonMultiRow : public luban::CfgBean 
{
    static bool deserializeExcelFromJsonMultiRow(::luban::ByteBuf& _buf, ::luban::SharedPtr<ExcelFromJsonMultiRow>& _out);

    virtual ~ExcelFromJsonMultiRow() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    ::luban::int32 x;
    ::luban::Vector<::luban::SharedPtr<test::TestRow>> items;

    static constexpr int __ID__ = 715335694;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct Foo : public luban::CfgBean 
{
    static bool deserializeFoo(::luban::ByteBuf& _buf, ::luban::SharedPtr<Foo>& _out);

    virtual ~Foo() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 y1;
    ::luban::int32 y2;
    ::luban::int32 y3;

    static constexpr int __ID__ = -1147950774;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct H1 : public luban::CfgBean 
{
    static bool deserializeH1(::luban::ByteBuf& _buf, ::luban::SharedPtr<H1>& _out);

    virtual ~H1() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::SharedPtr<test::H2> y2;
    ::luban::int32 y3;

    static constexpr int __ID__ = -1422503995;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct H2 : public luban::CfgBean 
{
    static bool deserializeH2(::luban::ByteBuf& _buf, ::luban::SharedPtr<H2>& _out);

    virtual ~H2() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 z2;
    ::luban::int32 z3;

    static constexpr int __ID__ = -1422503994;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct InnerGroup : public luban::CfgBean 
{
    static bool deserializeInnerGroup(::luban::ByteBuf& _buf, ::luban::SharedPtr<InnerGroup>& _out);

    virtual ~InnerGroup() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 y1;
    ::luban::int32 y2;
    ::luban::int32 y3;
    ::luban::int32 y4;

    static constexpr int __ID__ = -587873083;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct ItemBase : public luban::CfgBean 
{
    static bool deserializeItemBase(::luban::ByteBuf& _buf, ::luban::SharedPtr<ItemBase>& _out);

    virtual ~ItemBase() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    ::luban::String name;
    ::luban::String desc;

};

}

namespace test {

struct Decorator : public test::ItemBase 
{
    static bool deserializeDecorator(::luban::ByteBuf& _buf, ::luban::SharedPtr<Decorator>& _out);

    virtual ~Decorator() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 duration;

    static constexpr int __ID__ = -625155649;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct Equipment : public test::ItemBase 
{
    static bool deserializeEquipment(::luban::ByteBuf& _buf, ::luban::SharedPtr<Equipment>& _out);

    virtual ~Equipment() {}

    bool deserialize(::luban::ByteBuf& _buf);

    test::DemoEnum attr;
    ::luban::int32 value;

    static constexpr int __ID__ = -76837102;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct Item : public test::ItemBase 
{
    static bool deserializeItem(::luban::ByteBuf& _buf, ::luban::SharedPtr<Item>& _out);

    virtual ~Item() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 num;
    ::luban::int32 price;

    static constexpr int __ID__ = -1226641649;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct MultiIndexList : public luban::CfgBean 
{
    static bool deserializeMultiIndexList(::luban::ByteBuf& _buf, ::luban::SharedPtr<MultiIndexList>& _out);

    virtual ~MultiIndexList() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id1;
    ::luban::int64 id2;
    ::luban::String id3;
    ::luban::int32 num;
    ::luban::String desc;

    static constexpr int __ID__ = 2016237651;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct MultiRowRecord : public luban::CfgBean 
{
    static bool deserializeMultiRowRecord(::luban::ByteBuf& _buf, ::luban::SharedPtr<MultiRowRecord>& _out);

    virtual ~MultiRowRecord() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    ::luban::String name;
    ::luban::Vector<::luban::SharedPtr<test::MultiRowType1>> oneRows;
    ::luban::Vector<::luban::SharedPtr<test::MultiRowType1>> multiRows1;
    ::luban::Array<::luban::SharedPtr<test::MultiRowType1>> multiRows2;
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::MultiRowType2>> multiRows4;
    ::luban::Vector<::luban::SharedPtr<test::MultiRowType3>> multiRows5;
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::MultiRowType2>> multiRows6;
    ::luban::HashMap<::luban::int32, ::luban::int32> multiRows7;

    static constexpr int __ID__ = -501249394;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct MultiRowTitle : public luban::CfgBean 
{
    static bool deserializeMultiRowTitle(::luban::ByteBuf& _buf, ::luban::SharedPtr<MultiRowTitle>& _out);

    virtual ~MultiRowTitle() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    ::luban::String name;
    ::luban::SharedPtr<test::H1> x1;
    ::luban::SharedPtr<test::H2> x20;
    ::luban::Vector<::luban::SharedPtr<test::H2>> x2;
    ::luban::Array<::luban::SharedPtr<test::H2>> x3;
    ::luban::Array<::luban::SharedPtr<test::H2>> x4;

    static constexpr int __ID__ = 540002427;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct MultiRowType1 : public luban::CfgBean 
{
    static bool deserializeMultiRowType1(::luban::ByteBuf& _buf, ::luban::SharedPtr<MultiRowType1>& _out);

    virtual ~MultiRowType1() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    ::luban::int32 x;

    static constexpr int __ID__ = 540474970;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct MultiRowType2 : public luban::CfgBean 
{
    static bool deserializeMultiRowType2(::luban::ByteBuf& _buf, ::luban::SharedPtr<MultiRowType2>& _out);

    virtual ~MultiRowType2() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    ::luban::int32 x;
    ::luban::float32 y;

    static constexpr int __ID__ = 540474971;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct MultiRowType3 : public luban::CfgBean 
{
    static bool deserializeMultiRowType3(::luban::ByteBuf& _buf, ::luban::SharedPtr<MultiRowType3>& _out);

    virtual ~MultiRowType3() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    ::luban::Vector<::luban::SharedPtr<test::MultiRowType1>> items;

    static constexpr int __ID__ = 540474972;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct MultiUnionIndexList : public luban::CfgBean 
{
    static bool deserializeMultiUnionIndexList(::luban::ByteBuf& _buf, ::luban::SharedPtr<MultiUnionIndexList>& _out);

    virtual ~MultiUnionIndexList() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id1;
    ::luban::int64 id2;
    ::luban::String id3;
    ::luban::int32 num;
    ::luban::String desc;

    static constexpr int __ID__ = 1966847134;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct NotIndexList : public luban::CfgBean 
{
    static bool deserializeNotIndexList(::luban::ByteBuf& _buf, ::luban::SharedPtr<NotIndexList>& _out);

    virtual ~NotIndexList() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 x;
    ::luban::int32 y;

    static constexpr int __ID__ = -50446599;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct Path : public luban::CfgBean 
{
    static bool deserializePath(::luban::ByteBuf& _buf, ::luban::SharedPtr<Path>& _out);

    virtual ~Path() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    ::luban::String res;

    static constexpr int __ID__ = -1226450911;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct RefDynamicBase : public luban::CfgBean 
{
    static bool deserializeRefDynamicBase(::luban::ByteBuf& _buf, ::luban::SharedPtr<RefDynamicBase>& _out);

    virtual ~RefDynamicBase() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 x;

};

}

namespace test {

struct RefBean : public test::RefDynamicBase 
{
    static bool deserializeRefBean(::luban::ByteBuf& _buf, ::luban::SharedPtr<RefBean>& _out);

    virtual ~RefBean() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::Vector<::luban::int32> arr;

    static constexpr int __ID__ = 1963260263;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct SepBean1 : public luban::CfgBean 
{
    static bool deserializeSepBean1(::luban::ByteBuf& _buf, ::luban::SharedPtr<SepBean1>& _out);

    virtual ~SepBean1() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 a;
    ::luban::int32 b;
    ::luban::String c;

    static constexpr int __ID__ = -1534339393;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct SepVector : public luban::CfgBean 
{
    static bool deserializeSepVector(::luban::ByteBuf& _buf, ::luban::SharedPtr<SepVector>& _out);

    virtual ~SepVector() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 x;
    ::luban::int32 y;
    ::luban::int32 z;

    static constexpr int __ID__ = 252769477;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct Shape : public luban::CfgBean 
{
    static bool deserializeShape(::luban::ByteBuf& _buf, ::luban::SharedPtr<Shape>& _out);

    virtual ~Shape() {}

    bool deserialize(::luban::ByteBuf& _buf);


};

}

namespace test {

/**
 * 圆
 */
struct Circle : public test::Shape 
{
    static bool deserializeCircle(::luban::ByteBuf& _buf, ::luban::SharedPtr<Circle>& _out);

    virtual ~Circle() {}

    bool deserialize(::luban::ByteBuf& _buf);

    /**
     * 半径
     */
    ::luban::float32 radius;

    static constexpr int __ID__ = 2131829196;

    int getTypeId() const override { return __ID__; }
};

}

namespace test2 {

/**
 * 矩形
 */
struct Rectangle : public test::Shape 
{
    static bool deserializeRectangle(::luban::ByteBuf& _buf, ::luban::SharedPtr<Rectangle>& _out);

    virtual ~Rectangle() {}

    bool deserialize(::luban::ByteBuf& _buf);

    /**
     * 宽度
     */
    ::luban::float32 width;
    /**
     * 高度
     */
    ::luban::float32 height;

    static constexpr int __ID__ = 694982337;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct Test3 : public luban::CfgBean 
{
    static bool deserializeTest3(::luban::ByteBuf& _buf, ::luban::SharedPtr<Test3>& _out);

    virtual ~Test3() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 x;
    ::luban::int32 y;

    static constexpr int __ID__ = 638540133;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct TestBeRef : public luban::CfgBean 
{
    static bool deserializeTestBeRef(::luban::ByteBuf& _buf, ::luban::SharedPtr<TestBeRef>& _out);

    virtual ~TestBeRef() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    ::luban::int32 count;

    static constexpr int __ID__ = 1934403938;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

/**
 * 这是个测试excel结构
 */
struct TestExcelBean1 : public luban::CfgBean 
{
    static bool deserializeTestExcelBean1(::luban::ByteBuf& _buf, ::luban::SharedPtr<TestExcelBean1>& _out);

    virtual ~TestExcelBean1() {}

    bool deserialize(::luban::ByteBuf& _buf);

    /**
     * 最高品质
     */
    ::luban::int32 x1;
    /**
     * 黑色的
     */
    ::luban::String x2;
    /**
     * 蓝色的
     */
    ::luban::int32 x3;
    /**
     * 最差品质
     */
    ::luban::float32 x4;

    static constexpr int __ID__ = -1738345160;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

/**
 * 这是个测试excel结构
 */
struct TestExcelBean2 : public luban::CfgBean 
{
    static bool deserializeTestExcelBean2(::luban::ByteBuf& _buf, ::luban::SharedPtr<TestExcelBean2>& _out);

    virtual ~TestExcelBean2() {}

    bool deserialize(::luban::ByteBuf& _buf);

    /**
     * 最高品质
     */
    ::luban::int32 y1;
    /**
     * 黑色的
     */
    ::luban::String y2;
    /**
     * 蓝色的
     */
    ::luban::float32 y3;

    static constexpr int __ID__ = -1738345159;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct TestGlobal : public luban::CfgBean 
{
    static bool deserializeTestGlobal(::luban::ByteBuf& _buf, ::luban::SharedPtr<TestGlobal>& _out);

    virtual ~TestGlobal() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 unlockEquip;
    ::luban::int32 unlockHero;

    static constexpr int __ID__ = -12548655;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct TestIndex : public luban::CfgBean 
{
    static bool deserializeTestIndex(::luban::ByteBuf& _buf, ::luban::SharedPtr<TestIndex>& _out);

    virtual ~TestIndex() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    ::luban::Vector<::luban::SharedPtr<test::DemoType1>> eles;

    static constexpr int __ID__ = 1941154020;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct TestMap : public luban::CfgBean 
{
    static bool deserializeTestMap(::luban::ByteBuf& _buf, ::luban::SharedPtr<TestMap>& _out);

    virtual ~TestMap() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    ::luban::HashMap<::luban::int32, ::luban::int32> x1;
    ::luban::HashMap<::luban::int64, ::luban::int32> x2;
    ::luban::HashMap<::luban::String, ::luban::int32> x3;
    ::luban::HashMap<test::DemoEnum, ::luban::int32> x4;

    static constexpr int __ID__ = -543227410;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct TestMapper : public luban::CfgBean 
{
    static bool deserializeTestMapper(::luban::ByteBuf& _buf, ::luban::SharedPtr<TestMapper>& _out);

    virtual ~TestMapper() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    AudioType audioType;
    ::luban::SharedPtr<vec2> v2;

    static constexpr int __ID__ = 149110895;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct TestMultiColumn : public luban::CfgBean 
{
    static bool deserializeTestMultiColumn(::luban::ByteBuf& _buf, ::luban::SharedPtr<TestMultiColumn>& _out);

    virtual ~TestMultiColumn() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    ::luban::SharedPtr<test::Foo> a;
    ::luban::SharedPtr<test::Foo> b;
    ::luban::SharedPtr<test::Foo> c;

    static constexpr int __ID__ = -294473599;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct TestNull : public luban::CfgBean 
{
    static bool deserializeTestNull(::luban::ByteBuf& _buf, ::luban::SharedPtr<TestNull>& _out);

    virtual ~TestNull() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    ::luban::SharedPtr<::luban::int32> x1;
    ::luban::SharedPtr<test::DemoEnum> x2;
    ::luban::SharedPtr<test::DemoType1> x3;
    ::luban::SharedPtr<test::DemoDynamic> x4;
    ::luban::SharedPtr<::luban::String> s1;
    ::luban::SharedPtr<::luban::String> s2;

    static constexpr int __ID__ = 339868469;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct TestRef : public luban::CfgBean 
{
    static bool deserializeTestRef(::luban::ByteBuf& _buf, ::luban::SharedPtr<TestRef>& _out);

    virtual ~TestRef() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    ::luban::int32 x1;
    ::luban::int32 x12;
    ::luban::int32 x2;
    ::luban::int32 x3;
    ::luban::int32 x4;
    ::luban::Array<::luban::int32> a1;
    ::luban::Array<::luban::int32> a2;
    ::luban::Vector<::luban::int32> b1;
    ::luban::Vector<::luban::int32> b2;
    ::luban::HashSet<::luban::int32> c1;
    ::luban::HashSet<::luban::int32> c2;
    ::luban::HashMap<::luban::int32, ::luban::int32> d1;
    ::luban::HashMap<::luban::int32, ::luban::int32> d2;
    ::luban::int32 e1;
    ::luban::int64 e2;
    ::luban::String e3;
    ::luban::int32 f1;
    ::luban::int64 f2;
    ::luban::String f3;
    ::luban::SharedPtr<test::RefDynamicBase> s1;

    static constexpr int __ID__ = -543222491;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct TestRow : public luban::CfgBean 
{
    static bool deserializeTestRow(::luban::ByteBuf& _buf, ::luban::SharedPtr<TestRow>& _out);

    virtual ~TestRow() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 x;
    bool y;
    ::luban::String z;
    ::luban::SharedPtr<test::Test3> a;
    ::luban::Vector<::luban::int32> b;

    static constexpr int __ID__ = -543222164;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct TestScriptableObject : public luban::CfgBean 
{
    static bool deserializeTestScriptableObject(::luban::ByteBuf& _buf, ::luban::SharedPtr<TestScriptableObject>& _out);

    virtual ~TestScriptableObject() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    ::luban::String desc;
    ::luban::float32 rate;
    ::luban::int32 num;
    ::luban::SharedPtr<vec2> v2;
    ::luban::SharedPtr<vec3> v3;
    ::luban::SharedPtr<vec4> v4;

    static constexpr int __ID__ = -1896814350;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct TestSet : public luban::CfgBean 
{
    static bool deserializeTestSet(::luban::ByteBuf& _buf, ::luban::SharedPtr<TestSet>& _out);

    virtual ~TestSet() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    ::luban::String x0;
    ::luban::Vector<::luban::int32> x1;
    ::luban::Vector<::luban::int64> x2;
    ::luban::Vector<::luban::String> x3;
    ::luban::Vector<test::DemoEnum> x4;

    static constexpr int __ID__ = -543221516;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct TestSize : public luban::CfgBean 
{
    static bool deserializeTestSize(::luban::ByteBuf& _buf, ::luban::SharedPtr<TestSize>& _out);

    virtual ~TestSize() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::int32 id;
    ::luban::Array<::luban::int32> x1;
    ::luban::Vector<::luban::int32> x2;
    ::luban::HashSet<::luban::int32> x3;
    ::luban::HashMap<::luban::int32, ::luban::int32> x4;

    static constexpr int __ID__ = 340006319;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct TestString : public luban::CfgBean 
{
    static bool deserializeTestString(::luban::ByteBuf& _buf, ::luban::SharedPtr<TestString>& _out);

    virtual ~TestString() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::String id;
    ::luban::String s1;
    ::luban::String s2;
    ::luban::SharedPtr<test::CompactString> cs1;
    ::luban::SharedPtr<test::CompactString> cs2;

    static constexpr int __ID__ = 338485823;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

struct TestUeType : public luban::CfgBean 
{
    static bool deserializeTestUeType(::luban::ByteBuf& _buf, ::luban::SharedPtr<TestUeType>& _out);

    virtual ~TestUeType() {}

    bool deserialize(::luban::ByteBuf& _buf);

    bool x1;
    ::luban::byte x2;
    ::luban::int16 x3;
    ::luban::int32 x4;
    ::luban::int64 x5;
    ::luban::float32 x6;
    ::luban::String x10;
    ::luban::SharedPtr<test::DemoType1> x12;
    test::ETestUeType x13;
    ::luban::datetime t1;
    ::luban::Array<::luban::int32> k1;
    ::luban::Vector<::luban::int32> k2;
    ::luban::HashSet<::luban::int32> k5;
    ::luban::HashMap<::luban::int32, ::luban::int32> k8;
    ::luban::Vector<::luban::SharedPtr<test::DemoE2>> k9;

    static constexpr int __ID__ = 381013016;

    int getTypeId() const override { return __ID__; }
};

}



struct vec2 : public luban::CfgBean 
{
    static bool deserializevec2(::luban::ByteBuf& _buf, ::luban::SharedPtr<vec2>& _out);

    virtual ~vec2() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::float32 x;
    ::luban::float32 y;

    static constexpr int __ID__ = 3615518;

    int getTypeId() const override { return __ID__; }
};





struct vec3 : public luban::CfgBean 
{
    static bool deserializevec3(::luban::ByteBuf& _buf, ::luban::SharedPtr<vec3>& _out);

    virtual ~vec3() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::float32 x;
    ::luban::float32 y;
    ::luban::float32 z;

    static constexpr int __ID__ = 3615519;

    int getTypeId() const override { return __ID__; }
};





struct vec4 : public luban::CfgBean 
{
    static bool deserializevec4(::luban::ByteBuf& _buf, ::luban::SharedPtr<vec4>& _out);

    virtual ~vec4() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::float32 x;
    ::luban::float32 y;
    ::luban::float32 z;
    ::luban::float32 w;

    static constexpr int __ID__ = 3615520;

    int getTypeId() const override { return __ID__; }
};



namespace ai {


class TbBlackboard
{
    private:
    ::luban::HashMap<::luban::String, ::luban::SharedPtr<ai::Blackboard>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<ai::Blackboard>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<ai::Blackboard> _v;
            if(!ai::Blackboard::deserializeBlackboard(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->name] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::String, ::luban::SharedPtr<ai::Blackboard>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<ai::Blackboard>>& getDataList() const { return _dataList; }

    ai::Blackboard* getRaw(::luban::String key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<ai::Blackboard> get(::luban::String key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace ai {


class TbBehaviorTree
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<ai::BehaviorTree>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<ai::BehaviorTree>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<ai::BehaviorTree> _v;
            if(!ai::BehaviorTree::deserializeBehaviorTree(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<ai::BehaviorTree>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<ai::BehaviorTree>>& getDataList() const { return _dataList; }

    ai::BehaviorTree* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<ai::BehaviorTree> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace common {


class TbGlobalConfig
{
     private:
    ::luban::SharedPtr<common::GlobalConfig> _data;

    public:
    ::luban::SharedPtr<common::GlobalConfig> data() const { return _data; }

    bool load(::luban::ByteBuf& _buf)
    {
        int n;
        if (!_buf.readSize(n)) return false;
        if (n != 1) return false;
        if(!common::GlobalConfig::deserializeGlobalConfig(_buf, _data)) return false;
        return true;
    }


    /**
     * 背包容量
     */
    ::luban::int32& getX1() const { return _data->x1; }
    ::luban::int32& getX2() const { return _data->x2; }
    ::luban::int32& getX3() const { return _data->x3; }
    ::luban::int32& getX4() const { return _data->x4; }
    ::luban::int32& getX5() const { return _data->x5; }
    ::luban::int32& getX6() const { return _data->x6; }
    ::luban::Vector<::luban::int32>& getX7() const { return _data->x7; }
};

}

namespace item {

/**
 * 道具表
 */

class TbItem
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<item::Item>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<item::Item>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<item::Item> _v;
            if(!item::Item::deserializeItem(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<item::Item>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<item::Item>>& getDataList() const { return _dataList; }

    item::Item* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<item::Item> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace l10n {


class TbL10NDemo
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<l10n::L10NDemo>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<l10n::L10NDemo>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<l10n::L10NDemo> _v;
            if(!l10n::L10NDemo::deserializeL10NDemo(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<l10n::L10NDemo>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<l10n::L10NDemo>>& getDataList() const { return _dataList; }

    l10n::L10NDemo* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<l10n::L10NDemo> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace l10n {


class TbPatchDemo
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<l10n::PatchDemo>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<l10n::PatchDemo>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<l10n::PatchDemo> _v;
            if(!l10n::PatchDemo::deserializePatchDemo(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<l10n::PatchDemo>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<l10n::PatchDemo>>& getDataList() const { return _dataList; }

    l10n::PatchDemo* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<l10n::PatchDemo> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace tag {


class TbTestTag
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<tag::TestTag>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<tag::TestTag>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<tag::TestTag> _v;
            if(!tag::TestTag::deserializeTestTag(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<tag::TestTag>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<tag::TestTag>>& getDataList() const { return _dataList; }

    tag::TestTag* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<tag::TestTag> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbFullTypes
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::DemoType2>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<test::DemoType2>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<test::DemoType2> _v;
            if(!test::DemoType2::deserializeDemoType2(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->x4] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::DemoType2>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<test::DemoType2>>& getDataList() const { return _dataList; }

    test::DemoType2* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<test::DemoType2> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbSingleton
{
     private:
    ::luban::SharedPtr<test::DemoSingletonType> _data;

    public:
    ::luban::SharedPtr<test::DemoSingletonType> data() const { return _data; }

    bool load(::luban::ByteBuf& _buf)
    {
        int n;
        if (!_buf.readSize(n)) return false;
        if (n != 1) return false;
        if(!test::DemoSingletonType::deserializeDemoSingletonType(_buf, _data)) return false;
        return true;
    }


    ::luban::int32& getId() const { return _data->id; }
    ::luban::String& getName() const { return _data->name; }
    ::luban::SharedPtr<test::DemoDynamic>& getDate() const { return _data->date; }
};

}

namespace test {


class TbNotIndexList
{
    private:
        ::luban::Vector<::luban::SharedPtr<test::NotIndexList>> _dataList;
    
        public:
        bool load(::luban::ByteBuf& _buf)
        {        
            int n;
            if (!_buf.readSize(n)) return false;
            for(; n > 0 ; --n)
            {
                ::luban::SharedPtr<test::NotIndexList> _v;
                if(!test::NotIndexList::deserializeNotIndexList(_buf, _v)) return false;
                _dataList.push_back(_v);
            }
            return true;
        }

        const ::luban::Vector<::luban::SharedPtr<test::NotIndexList>>& getDataList() const { return _dataList; }

            test::NotIndexList* getRaw(size_t index) const
            { 
                return _dataList[index].get();
            }

            ::luban::SharedPtr<test::NotIndexList> get(size_t index) const
            { 
                return _dataList[index];
            }
};

}

namespace test {


class TbMultiUnionIndexList
{
    private:
        ::luban::Vector<::luban::SharedPtr<test::MultiUnionIndexList>> _dataList;

    
        public:
        bool load(::luban::ByteBuf& _buf)
        {        
            int n;
            if (!_buf.readSize(n)) return false;
            for(; n > 0 ; --n)
            {
                ::luban::SharedPtr<test::MultiUnionIndexList> _v;
                if(!test::MultiUnionIndexList::deserializeMultiUnionIndexList(_buf, _v)) return false;
                _dataList.push_back(_v);

            }
            return true;
        }

        const ::luban::Vector<::luban::SharedPtr<test::MultiUnionIndexList>>& getDataList() const { return _dataList; }


};

}

namespace test {


class TbMultiIndexList
{
    private:
        ::luban::Vector<::luban::SharedPtr<test::MultiIndexList>> _dataList;
        ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::MultiIndexList>> _dataMap_id1;
        ::luban::HashMap<::luban::int64, ::luban::SharedPtr<test::MultiIndexList>> _dataMap_id2;
        ::luban::HashMap<::luban::String, ::luban::SharedPtr<test::MultiIndexList>> _dataMap_id3;
    
        public:
        bool load(::luban::ByteBuf& _buf)
        {        
            int n;
            if (!_buf.readSize(n)) return false;
            for(; n > 0 ; --n)
            {
                ::luban::SharedPtr<test::MultiIndexList> _v;
                if(!test::MultiIndexList::deserializeMultiIndexList(_buf, _v)) return false;
                _dataList.push_back(_v);
                _dataMap_id1[_v->id1] = _v;
                _dataMap_id2[_v->id2] = _v;
                _dataMap_id3[_v->id3] = _v;
            }
            return true;
        }

        const ::luban::Vector<::luban::SharedPtr<test::MultiIndexList>>& getDataList() const { return _dataList; }

        ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::MultiIndexList>>& getDataMapByid1()
        {
            return _dataMap_id1;
        }
        test::MultiIndexList* getRawByid1(::luban::int32 key)
        {                    
            auto it = _dataMap_id1.find(key);
            return it != _dataMap_id1.end() ? it->second.get() : nullptr;
        }
        ::luban::SharedPtr<test::MultiIndexList> getByid1(::luban::int32 key)
        {
            auto it = _dataMap_id1.find(key);
            return it != _dataMap_id1.end() ? it->second : nullptr;
        }
        ::luban::HashMap<::luban::int64, ::luban::SharedPtr<test::MultiIndexList>>& getDataMapByid2()
        {
            return _dataMap_id2;
        }
        test::MultiIndexList* getRawByid2(::luban::int64 key)
        {                    
            auto it = _dataMap_id2.find(key);
            return it != _dataMap_id2.end() ? it->second.get() : nullptr;
        }
        ::luban::SharedPtr<test::MultiIndexList> getByid2(::luban::int64 key)
        {
            auto it = _dataMap_id2.find(key);
            return it != _dataMap_id2.end() ? it->second : nullptr;
        }
        ::luban::HashMap<::luban::String, ::luban::SharedPtr<test::MultiIndexList>>& getDataMapByid3()
        {
            return _dataMap_id3;
        }
        test::MultiIndexList* getRawByid3(::luban::String key)
        {                    
            auto it = _dataMap_id3.find(key);
            return it != _dataMap_id3.end() ? it->second.get() : nullptr;
        }
        ::luban::SharedPtr<test::MultiIndexList> getByid3(::luban::String key)
        {
            auto it = _dataMap_id3.find(key);
            return it != _dataMap_id3.end() ? it->second : nullptr;
        }
};

}

namespace test {


class TbDataFromMisc
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::DemoType2>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<test::DemoType2>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<test::DemoType2> _v;
            if(!test::DemoType2::deserializeDemoType2(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->x4] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::DemoType2>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<test::DemoType2>>& getDataList() const { return _dataList; }

    test::DemoType2* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<test::DemoType2> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbMultiRowRecord
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::MultiRowRecord>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<test::MultiRowRecord>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<test::MultiRowRecord> _v;
            if(!test::MultiRowRecord::deserializeMultiRowRecord(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::MultiRowRecord>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<test::MultiRowRecord>>& getDataList() const { return _dataList; }

    test::MultiRowRecord* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<test::MultiRowRecord> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbTestMultiColumn
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::TestMultiColumn>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<test::TestMultiColumn>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<test::TestMultiColumn> _v;
            if(!test::TestMultiColumn::deserializeTestMultiColumn(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::TestMultiColumn>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<test::TestMultiColumn>>& getDataList() const { return _dataList; }

    test::TestMultiColumn* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<test::TestMultiColumn> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbMultiRowTitle
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::MultiRowTitle>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<test::MultiRowTitle>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<test::MultiRowTitle> _v;
            if(!test::MultiRowTitle::deserializeMultiRowTitle(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::MultiRowTitle>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<test::MultiRowTitle>>& getDataList() const { return _dataList; }

    test::MultiRowTitle* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<test::MultiRowTitle> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbTestNull
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::TestNull>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<test::TestNull>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<test::TestNull> _v;
            if(!test::TestNull::deserializeTestNull(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::TestNull>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<test::TestNull>>& getDataList() const { return _dataList; }

    test::TestNull* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<test::TestNull> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbDemoPrimitive
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::DemoPrimitiveTypesTable>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<test::DemoPrimitiveTypesTable>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<test::DemoPrimitiveTypesTable> _v;
            if(!test::DemoPrimitiveTypesTable::deserializeDemoPrimitiveTypesTable(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->x4] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::DemoPrimitiveTypesTable>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<test::DemoPrimitiveTypesTable>>& getDataList() const { return _dataList; }

    test::DemoPrimitiveTypesTable* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<test::DemoPrimitiveTypesTable> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbTestString
{
    private:
    ::luban::HashMap<::luban::String, ::luban::SharedPtr<test::TestString>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<test::TestString>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<test::TestString> _v;
            if(!test::TestString::deserializeTestString(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::String, ::luban::SharedPtr<test::TestString>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<test::TestString>>& getDataList() const { return _dataList; }

    test::TestString* getRaw(::luban::String key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<test::TestString> get(::luban::String key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbDemoGroup
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::DemoGroup>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<test::DemoGroup>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<test::DemoGroup> _v;
            if(!test::DemoGroup::deserializeDemoGroup(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::DemoGroup>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<test::DemoGroup>>& getDataList() const { return _dataList; }

    test::DemoGroup* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<test::DemoGroup> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbDemoGroup_C
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::DemoGroup>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<test::DemoGroup>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<test::DemoGroup> _v;
            if(!test::DemoGroup::deserializeDemoGroup(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::DemoGroup>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<test::DemoGroup>>& getDataList() const { return _dataList; }

    test::DemoGroup* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<test::DemoGroup> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbDemoGroup_S
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::DemoGroup>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<test::DemoGroup>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<test::DemoGroup> _v;
            if(!test::DemoGroup::deserializeDemoGroup(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::DemoGroup>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<test::DemoGroup>>& getDataList() const { return _dataList; }

    test::DemoGroup* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<test::DemoGroup> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbDemoGroup_E
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::DemoGroup>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<test::DemoGroup>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<test::DemoGroup> _v;
            if(!test::DemoGroup::deserializeDemoGroup(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::DemoGroup>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<test::DemoGroup>>& getDataList() const { return _dataList; }

    test::DemoGroup* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<test::DemoGroup> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbTestGlobal
{
     private:
    ::luban::SharedPtr<test::TestGlobal> _data;

    public:
    ::luban::SharedPtr<test::TestGlobal> data() const { return _data; }

    bool load(::luban::ByteBuf& _buf)
    {
        int n;
        if (!_buf.readSize(n)) return false;
        if (n != 1) return false;
        if(!test::TestGlobal::deserializeTestGlobal(_buf, _data)) return false;
        return true;
    }


    ::luban::int32& getUnlockEquip() const { return _data->unlockEquip; }
    ::luban::int32& getUnlockHero() const { return _data->unlockHero; }
};

}

namespace test {


class TbTestBeRef
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::TestBeRef>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<test::TestBeRef>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<test::TestBeRef> _v;
            if(!test::TestBeRef::deserializeTestBeRef(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::TestBeRef>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<test::TestBeRef>>& getDataList() const { return _dataList; }

    test::TestBeRef* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<test::TestBeRef> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbTestBeRef2
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::TestBeRef>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<test::TestBeRef>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<test::TestBeRef> _v;
            if(!test::TestBeRef::deserializeTestBeRef(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::TestBeRef>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<test::TestBeRef>>& getDataList() const { return _dataList; }

    test::TestBeRef* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<test::TestBeRef> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbTestRef
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::TestRef>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<test::TestRef>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<test::TestRef> _v;
            if(!test::TestRef::deserializeTestRef(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::TestRef>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<test::TestRef>>& getDataList() const { return _dataList; }

    test::TestRef* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<test::TestRef> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbTestSize
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::TestSize>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<test::TestSize>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<test::TestSize> _v;
            if(!test::TestSize::deserializeTestSize(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::TestSize>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<test::TestSize>>& getDataList() const { return _dataList; }

    test::TestSize* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<test::TestSize> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbTestSet
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::TestSet>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<test::TestSet>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<test::TestSet> _v;
            if(!test::TestSet::deserializeTestSet(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::TestSet>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<test::TestSet>>& getDataList() const { return _dataList; }

    test::TestSet* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<test::TestSet> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbDetectCsvEncoding
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::DetectEncoding>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<test::DetectEncoding>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<test::DetectEncoding> _v;
            if(!test::DetectEncoding::deserializeDetectEncoding(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::DetectEncoding>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<test::DetectEncoding>>& getDataList() const { return _dataList; }

    test::DetectEncoding* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<test::DetectEncoding> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbItem2
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::ItemBase>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<test::ItemBase>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<test::ItemBase> _v;
            if(!test::ItemBase::deserializeItemBase(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::ItemBase>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<test::ItemBase>>& getDataList() const { return _dataList; }

    test::ItemBase* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<test::ItemBase> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbTestIndex
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::TestIndex>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<test::TestIndex>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<test::TestIndex> _v;
            if(!test::TestIndex::deserializeTestIndex(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::TestIndex>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<test::TestIndex>>& getDataList() const { return _dataList; }

    test::TestIndex* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<test::TestIndex> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbTestMap
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::TestMap>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<test::TestMap>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<test::TestMap> _v;
            if(!test::TestMap::deserializeTestMap(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::TestMap>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<test::TestMap>>& getDataList() const { return _dataList; }

    test::TestMap* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<test::TestMap> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbExcelFromJson
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::ExcelFromJson>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<test::ExcelFromJson>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<test::ExcelFromJson> _v;
            if(!test::ExcelFromJson::deserializeExcelFromJson(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->x4] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::ExcelFromJson>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<test::ExcelFromJson>>& getDataList() const { return _dataList; }

    test::ExcelFromJson* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<test::ExcelFromJson> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbCompositeJsonTable1
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::CompositeJsonTable1>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<test::CompositeJsonTable1>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<test::CompositeJsonTable1> _v;
            if(!test::CompositeJsonTable1::deserializeCompositeJsonTable1(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::CompositeJsonTable1>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<test::CompositeJsonTable1>>& getDataList() const { return _dataList; }

    test::CompositeJsonTable1* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<test::CompositeJsonTable1> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbCompositeJsonTable2
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::CompositeJsonTable2>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<test::CompositeJsonTable2>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<test::CompositeJsonTable2> _v;
            if(!test::CompositeJsonTable2::deserializeCompositeJsonTable2(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::CompositeJsonTable2>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<test::CompositeJsonTable2>>& getDataList() const { return _dataList; }

    test::CompositeJsonTable2* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<test::CompositeJsonTable2> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbCompositeJsonTable3
{
     private:
    ::luban::SharedPtr<test::CompositeJsonTable3> _data;

    public:
    ::luban::SharedPtr<test::CompositeJsonTable3> data() const { return _data; }

    bool load(::luban::ByteBuf& _buf)
    {
        int n;
        if (!_buf.readSize(n)) return false;
        if (n != 1) return false;
        if(!test::CompositeJsonTable3::deserializeCompositeJsonTable3(_buf, _data)) return false;
        return true;
    }


    ::luban::int32& getA() const { return _data->a; }
    ::luban::int32& getB() const { return _data->b; }
};

}

namespace test {


class TbExcelFromJsonMultiRow
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::ExcelFromJsonMultiRow>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<test::ExcelFromJsonMultiRow>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<test::ExcelFromJsonMultiRow> _v;
            if(!test::ExcelFromJsonMultiRow::deserializeExcelFromJsonMultiRow(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::ExcelFromJsonMultiRow>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<test::ExcelFromJsonMultiRow>>& getDataList() const { return _dataList; }

    test::ExcelFromJsonMultiRow* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<test::ExcelFromJsonMultiRow> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbTestScriptableObject
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::TestScriptableObject>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<test::TestScriptableObject>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<test::TestScriptableObject> _v;
            if(!test::TestScriptableObject::deserializeTestScriptableObject(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::TestScriptableObject>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<test::TestScriptableObject>>& getDataList() const { return _dataList; }

    test::TestScriptableObject* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<test::TestScriptableObject> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbPath
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::Path>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<test::Path>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<test::Path> _v;
            if(!test::Path::deserializePath(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::Path>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<test::Path>>& getDataList() const { return _dataList; }

    test::Path* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<test::Path> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbTestMapper
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::TestMapper>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<test::TestMapper>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<test::TestMapper> _v;
            if(!test::TestMapper::deserializeTestMapper(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<test::TestMapper>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<test::TestMapper>>& getDataList() const { return _dataList; }

    test::TestMapper* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<test::TestMapper> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

namespace test {


class TbDefineFromExcel2
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<DefineFromExcel2>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<DefineFromExcel2>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<DefineFromExcel2> _v;
            if(!DefineFromExcel2::deserializeDefineFromExcel2(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<DefineFromExcel2>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<DefineFromExcel2>>& getDataList() const { return _dataList; }

    DefineFromExcel2* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<DefineFromExcel2> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};

}

class Tables
{
    public:
     ai::TbBlackboard TbBlackboard;
     ai::TbBehaviorTree TbBehaviorTree;
     common::TbGlobalConfig TbGlobalConfig;
    /**
     * 道具表
     */
     item::TbItem TbItem;
     l10n::TbL10NDemo TbL10NDemo;
     l10n::TbPatchDemo TbPatchDemo;
     tag::TbTestTag TbTestTag;
     test::TbFullTypes TbFullTypes;
     test::TbSingleton TbSingleton;
     test::TbNotIndexList TbNotIndexList;
     test::TbMultiUnionIndexList TbMultiUnionIndexList;
     test::TbMultiIndexList TbMultiIndexList;
     test::TbDataFromMisc TbDataFromMisc;
     test::TbMultiRowRecord TbMultiRowRecord;
     test::TbTestMultiColumn TbTestMultiColumn;
     test::TbMultiRowTitle TbMultiRowTitle;
     test::TbTestNull TbTestNull;
     test::TbDemoPrimitive TbDemoPrimitive;
     test::TbTestString TbTestString;
     test::TbDemoGroup TbDemoGroup;
     test::TbDemoGroup_C TbDemoGroup_C;
     test::TbDemoGroup_S TbDemoGroup_S;
     test::TbDemoGroup_E TbDemoGroup_E;
     test::TbTestGlobal TbTestGlobal;
     test::TbTestBeRef TbTestBeRef;
     test::TbTestBeRef2 TbTestBeRef2;
     test::TbTestRef TbTestRef;
     test::TbTestSize TbTestSize;
     test::TbTestSet TbTestSet;
     test::TbDetectCsvEncoding TbDetectCsvEncoding;
     test::TbItem2 TbItem2;
     test::TbTestIndex TbTestIndex;
     test::TbTestMap TbTestMap;
     test::TbExcelFromJson TbExcelFromJson;
     test::TbCompositeJsonTable1 TbCompositeJsonTable1;
     test::TbCompositeJsonTable2 TbCompositeJsonTable2;
     test::TbCompositeJsonTable3 TbCompositeJsonTable3;
     test::TbExcelFromJsonMultiRow TbExcelFromJsonMultiRow;
     test::TbTestScriptableObject TbTestScriptableObject;
     test::TbPath TbPath;
     test::TbTestMapper TbTestMapper;
     test::TbDefineFromExcel2 TbDefineFromExcel2;

    bool load(::luban::Loader<::luban::ByteBuf> loader)
    {
        ::luban::ByteBuf buf;
        buf.clear();
        if (!loader(buf, "ai_tbblackboard")) return false;
        if (!TbBlackboard.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "ai_tbbehaviortree")) return false;
        if (!TbBehaviorTree.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "common_tbglobalconfig")) return false;
        if (!TbGlobalConfig.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "item_tbitem")) return false;
        if (!TbItem.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "l10n_tbl10ndemo")) return false;
        if (!TbL10NDemo.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "l10n_tbpatchdemo")) return false;
        if (!TbPatchDemo.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "tag_tbtesttag")) return false;
        if (!TbTestTag.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbfulltypes")) return false;
        if (!TbFullTypes.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbsingleton")) return false;
        if (!TbSingleton.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbnotindexlist")) return false;
        if (!TbNotIndexList.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbmultiunionindexlist")) return false;
        if (!TbMultiUnionIndexList.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbmultiindexlist")) return false;
        if (!TbMultiIndexList.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbdatafrommisc")) return false;
        if (!TbDataFromMisc.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbmultirowrecord")) return false;
        if (!TbMultiRowRecord.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbtestmulticolumn")) return false;
        if (!TbTestMultiColumn.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbmultirowtitle")) return false;
        if (!TbMultiRowTitle.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbtestnull")) return false;
        if (!TbTestNull.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbdemoprimitive")) return false;
        if (!TbDemoPrimitive.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbteststring")) return false;
        if (!TbTestString.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbdemogroup")) return false;
        if (!TbDemoGroup.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbdemogroup_c")) return false;
        if (!TbDemoGroup_C.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbdemogroup_s")) return false;
        if (!TbDemoGroup_S.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbdemogroup_e")) return false;
        if (!TbDemoGroup_E.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbtestglobal")) return false;
        if (!TbTestGlobal.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbtestberef")) return false;
        if (!TbTestBeRef.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbtestberef2")) return false;
        if (!TbTestBeRef2.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbtestref")) return false;
        if (!TbTestRef.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbtestsize")) return false;
        if (!TbTestSize.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbtestset")) return false;
        if (!TbTestSet.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbdetectcsvencoding")) return false;
        if (!TbDetectCsvEncoding.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbitem2")) return false;
        if (!TbItem2.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbtestindex")) return false;
        if (!TbTestIndex.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbtestmap")) return false;
        if (!TbTestMap.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbexcelfromjson")) return false;
        if (!TbExcelFromJson.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbcompositejsontable1")) return false;
        if (!TbCompositeJsonTable1.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbcompositejsontable2")) return false;
        if (!TbCompositeJsonTable2.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbcompositejsontable3")) return false;
        if (!TbCompositeJsonTable3.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbexcelfromjsonmultirow")) return false;
        if (!TbExcelFromJsonMultiRow.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbtestscriptableobject")) return false;
        if (!TbTestScriptableObject.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbpath")) return false;
        if (!TbPath.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbtestmapper")) return false;
        if (!TbTestMapper.load(buf)) return false;
        buf.clear();
        if (!loader(buf, "test_tbdefinefromexcel2")) return false;
        if (!TbDefineFromExcel2.load(buf)) return false;
        return true;
    }
};



}

